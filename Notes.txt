1. Can have multiple class in a java class file, but only one class in top-level, means only one class can be public. the others can not be given the public access modifier.
2. public void setName(String name) => the setName(String name) is called signature (signature includes the method name and the argument of the method)
3. java FodenClass "Foden" Foden  => input "Foden" or Foden can both be ok with java runtime
4. import java.util.* will import all classes under java.util, but not import subfolder of util folder
5. can compile multiple java class in one command: javac packagea/*.java packageb/*.java
6. if want to compile java file to class file and stored in another folder name classes: javac -d classes packagea/*.java packageb/*.java
7. to run the class files in 6:
    java -cp classes packagea.nameOfOneClassFileWithoutExtension
    or
    java -classpath ............................................
    or
    java --class-path ..........................................
8. java -cp ".;C:\com\demo\deps;C:\com\demo\myJar.jar" myPackage.MyApp
    To understand the above command, see below:
    C:\
     └── com\
         └── demo\
             ├── deps\
             │   ├── libA.jar
             │   └── libB.jar
             ├── myJar.jar
             │   └── myPackage\
             │       └── MyApp.class
             └── main.class
     first java to start jvm to execute java application
     second -cp to define classpaths, which is the path to the class files and Jar files that the application will need. The classpath contains multiple paths, separated by <;> (on Windows) or <:> on Unix/Linux
     third is class path: the first <.> represents the current directory which you are executing the command. Java will treat current folder as a base directory
                          C:\com\demo\deps This is the path to a directory that contains dependency libraries that MyApp need (libA.jar and libB.jar)
                          C:\com\demo\myJar.jar This is a specific jar file that contains compiled source code. For example, this file might contain some classes that your application uses
     Last is myPackage.MyApp This is the full name of the class. MyApp must have a method public static void main(String[] args) for java to know where to start.
9. Create your own jar file (from files in current folder)
    jar -cvf myNewJarFile.jar .
    or
    jar --create --verbose --file myNewJarFile.jar .
10. Create your own jar file (from files in custom folder)
    jar -cvf myNewJarFile.jar -C myFolder
    or
    jar --create --verbose --file myNewJarFile.jar -C myFolder
11. Foden foden = new Foden(); => In Java, when you create an instance of a class, the static blocks are executed only once when the class is loaded into memory,
                                  before any instances of the class are created. So, when you execute Foden foden = new Foden();, any static block in the Foden class
                                  will run before the constructor of Foden is executed.
12. Primitive Types:
    Definition: These are the basic data types provided by Java. They hold their values directly and are not objects.
    Characteristics:
            Fixed size.
            Stored in the stack memory.
            Represent simple values.
            Cannot be null.
    boolean: Type true or false, default value is false
    byte: 8bit integral value, from -128 to 127, default value is 0
    short: 16bit integral value, from -32,768 to 32,767, default value is 0
    int: 32bit integral value, from -2,147,483,648 to 2,147,483,647, default value is 0
    long: 64bit integral value, from -2^63 to 2^63 - 1, default value is 0L, example value is 5106L
    float: 32bit floating value, default value is 0.0f, example value is 511.183f
    double: 64bit floating value, default value is 0.0, example value is 511.183
    char: 16bit unicode value, from 0 to 65,535, default value is \u0000, example value is 'C'
    => To keep in mind:
        in Java, boolean true and false are completely unrelated to 1 and 0
        all numeric types are signed (allow negative numbers)
        float requires f (or F) at the end
            float x = 2.7; // Does not compile
            float x = 2.7f; // OK
        long requires l (or and preferably L) at the end
            long a = 45366546327; // Does not compile
            long a = 45366546327L; // OK
        for readability the use of underscore (_) is allowed, but NOT in the beginning or the end
            int a = 1_000_000; // normal usage
            int b = 1_2; // OK, but not very useful
            int c = 1________2; // even less useful, but still OK
            double d = 1_000_000.000_001 // OK and makes sense
            double x = _10.1; // NOK, do not allowed underscore at the beginning or the end
13. Non-Primitive Types:
    Definition: These are more complex data types that are derived from primitive types. They can hold multiple values and are always objects.
    Characteristics:
            Variable size.
            Stored in the heap memory.
            Can represent collections of values or complex data.
            Can be null.
    Strings: are not primitive types in Java, but they are commonly use like primitive
            String greeting = "hello world";
            ......................
            ......................
            ...Tobe continued.....
14. Stack and Heap memory:
    Stack:
        Definition: The stack is a region of memory that stores temporary variables created by each method (function) call. It operates in a last-in, first-out (LIFO) manner.
        Characteristics:
                Storage of Local Variables: Stack memory is used for storing local variables, method parameters, and references to objects in the heap.
                Automatic Memory Management: Memory is automatically allocated and deallocated. When a method is called, a new block (frame) is created on the stack.
                                             When the method returns, its frame is removed.
                Limited Size: Stack memory is generally smaller than heap memory. Its size is defined at the start of the application and can lead to a StackOverflowError
                              if too much memory is used (e.g., in deep recursion).
                Fast Access: Accessing data from the stack is faster than from the heap due to its structured nature.
        Example:
            public class StackExample {
                public static void main(String[] args) {
                    int localVariable = 10;  // Stored in stack
                    anotherMethod();
                }

                public static void anotherMethod() {
                    int anotherVariable = 20; // Also stored in stack
                }
            }
    Heap:
        Definition: The heap is a region of memory used for dynamic memory allocation, where objects are stored. It is managed by the Java Virtual Machine (JVM).
        Characteristics:
                Storage of Objects: All Java objects and their instance variables are stored in heap memory.
                Dynamic Allocation: Memory can be allocated and deallocated dynamically at runtime using the new keyword.
                                    Unlike the stack, memory in the heap is not automatically freed when a method exits.
                Garbage Collection: The JVM includes a garbage collector that automatically reclaims memory used by objects that are no longer referenced,
                                    helping to prevent memory leaks.
                Larger Size: Heap memory is generally larger than stack memory, allowing more significant data storage.
                             However, accessing heap memory can be slower than stack memory due to the overhead of memory management.
        Example:
            public class HeapExample {
                public static void main(String[] args) {
                    MyObject obj = new MyObject(); // obj is a reference stored in the stack, MyObject is in the heap
                }
            }

            class MyObject {
                int value;

                MyObject() {
                    value = 10; // Instance variable stored in heap
                }
            }
15. Text Blocks: Is a new feature in Java 15
    i.e
        The old way: String title = "\"Java Core\"\n    by Foden Duong";
        String title = """
            "Java Core"
               by Foden Duong"""";
        //The output:
            "Java Core"
               by Foden Duong
    => Remember, after the first """, should be the new line
       and after the second """, can be the new line or the same line but recommended the new line if you want compiler to insert a new line
       Any whitespace before the first non-empty character in the line after the 1st """ will be ignored by compiler.
       Compiler looks for the first non-empty character.
       But once the compiler finds the first non-empty character, then these spaces (before by Foden Duong""") will be essential,
       so these are part of the string.
16. Variables: is a name for a piece of memory which stores data
    To declare a variable: int x;
    To initialize a variable: int x = 5;
    Name of the variable (method, class, interface, package, ...) is called identifier
    Identifier rules:
        Must begin with a letter, currency symbol ($, ...), or underscore(_)
        Can include numbers, but not start with a number
        Single underscore(_) is not allowed as an identifier
        You cannot use the reserved word (like: abstract, case, continue, super, import, return, volatile, goto,...)
    Naming conventions:
        For variables, use camelCase
        For constants, use SNAKE_CASE
        Identifier of classes, interfaces, enums records start with first uppercase letter (e.g MyClass, MyInterface, StudentRecord)
        Identifiers variables and methods start with first lowercase letter (e.g fullName, getFullName())
        => Java identifier are case-sensitive !!
    Multiple variables can be declared/initialized in a single line (bad practice, but it compiles)
        int x, y;
        String firstName = "Foden", lastName = "Duong";
        boolean v = true, w, z = false;
    but you  cannot mix types (cannot declare variables of different type in a single line)
        int x, String name; // DOES NOT COMPILE
        or
        int x,
            String name: // "This is same line, as Java seperate lines by semicolon (;)", so DOES NOT COMPILE
    Three kinds of variables:
        Local variable - exist only within the block of code { ... }
        Instance variables (fields) - defined within the specific instance of the object
        Class variables - belong to a class and is shared with all instances of the class(marked with keyword static)
    Instance and class variables don't require initialization
        In-case you don't initialize variable, java will assume the defaults values of their type (i.e for doubles type, the default value is 0.0)
    Local variables must be initialized before use
        public int doesNotcompile(){
            int a = 3;
            int b;
            return a + b; // DOES NOT COMPILE as we use b but do not initialize it yet
        }
        but
        public int doesCompile(){
            int a = 5;
            int b = 3;
            int c;
            return a + b; // COMPIlE because c is not initialized but it's never used
        }
    Be careful if initialization is within if-statement
            public void doesNotCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5; // might never be reached
                }
                System.out.println(a); // DOES NOT COMPILE, variable a might not have been initialized
            }
            but
            public void doesCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5;
                } else {
                    a = 2;
                }
                System.out.println(a); // COMPILE, because this variable a will be initialized one way or another
            }
    Final variables (constants)
        final int MAX_HEIGHT = 100;
        Final can be applied to a reference:
            final int[] MY_NUMBERS = new int[5];
            in this case, reference cannot be modified, but the content of the object can:
                        MY_NUMBERS[2] = 10; // OK
                        MY_NUMBERS = null; // DOES NOT COMPILE as you are trying to modified the reference
    Variable scope:
        Local variable: in scope from { to }
        Method parameters: in scope for the duration of the method
        Instance variablé: in scope from declaration until the object is eligible for garbage collector
        Class variables: in scope from declaration until the program ends
17. Arguments and parameters in Java (Đối số và tham số trong Java):
    public void greeting(String message){ // message is parameter
        System.out.println(message);
    }
    greeting("Welcome to Java Core"); // Welcome to Java Core is argument
    => Tham số (parameter) được định nghĩa trong hàm
       Đối số (argument) là giá trị truyền vào khi gọi hàm