1. Can have multiple class in a java class file, but only one class in top-level, means only one class can be public. the others can not be given the public access modifier.
    Every class in java is automatically a subclass of the Object class
2. public void setName(String name) => the setName(String name) is called signature (signature includes the method name and the argument of the method)
3. java FodenClass "Foden" Foden  => input "Foden" or Foden can both be ok with java runtime
4. import java.util.* will import all classes under java.util, but not import subfolder of util folder
5. Errors and Exceptions overview in Java:
            Throwable (java.lang.Throwable)
              |-- Error (java.lang.Error) => also called unchecked exceptions
              |     |-- LinkageError
              |     |     |-- ClassNotFoundError
              |     |     |-- NoClassDefFoundError
              |     |-- VirtualMachineError
              |           |-- OutOfMemoryError
              |           |-- StackOverflowError
              |-- Exception (java.lang.Exception)
                   |-- IOException
                   |     |-- FileNotFoundException
                   |     |-- EOFException
                   |-- SQLException
                   |-- ClassNotFoundException
                   |-- RuntimeException (java.lang.RuntimeException) => also called unchecked exceptions
                        |-- ArithmeticException
                        |-- NullPointerException
                        |-- ArrayIndexOutOfBoundsException
                        |-- IllegalArgumentException
                        |     |-- NumberFormatException
                        |-- ClassCastException
                        |-- IllegalStateException
6. can compile multiple java class in one command: javac packagea/*.java packageb/*.java
   if want to compile java file to class file and stored in another folder name classes: javac -d classes packagea/*.java packageb/*.java
7. to run the class files in 6:
    java -cp classes packagea.nameOfOneClassFileWithoutExtension
    or
    java -classpath ............................................
    or
    java --class-path ..........................................
8. java -cp ".;C:\com\demo\deps;C:\com\demo\myJar.jar" myPackage.MyApp
    To understand the above command, see below:
    C:\
     └── com\
         └── demo\
             ├── deps\
             │   ├── libA.jar
             │   └── libB.jar
             ├── myJar.jar
             │   └── myPackage\
             │       └── MyApp.class
             └── main.class
     first java to start jvm to execute java application
     second -cp to define classpaths, which is the path to the class files and Jar files that the application will need. The classpath contains multiple paths, separated by <;> semicolon (on Windows) or <:> colon on Unix/Linux
     third is class path: the first <.> represents the current directory which you are executing the command. Java will treat current folder as a base directory
                          C:\com\demo\deps This is the path to a directory that contains dependency libraries that MyApp need (libA.jar and libB.jar)
                          C:\com\demo\myJar.jar This is a specific jar file that contains compiled source code. For example, this file might contain some classes that your application uses
     Last is myPackage.MyApp This is the full name of the class. MyApp must have a method public static void main(String[] args) for java to know where to start.
9. Create your own jar file (from files in current folder)
    jar -cvf myNewJarFile.jar .
    or
    jar --create --verbose --file myNewJarFile.jar .
10. Create your own jar file (from files in custom folder)
    jar -cvf myNewJarFile.jar -C myFolder
    or
    jar --create --verbose --file myNewJarFile.jar -C myFolder
11. Foden foden = new Foden(); => In Java, when you create an instance of a class, the static blocks are executed only once when the class is loaded into memory,
                                  before any instances of the class are created. So, when you execute Foden foden = new Foden(); any static block in the Foden class
                                  will run before the constructor of Foden is executed.
12. Primitive Types:
    Definition: These are the basic data types provided by Java. They hold their values directly and are not objects.
        Characteristics:
                Fixed size.
                Stored in the stack memory.
                Represent simple values.
                Cannot be null.
        boolean: Type true or false, default value is false
        byte: 8bit integral value, from -128 to 127, default value is 0
        short: 16bit integral value, from -32,768 to 32,767, default value is 0
        int: 32bit integral value, from -2,147,483,648 to 2,147,483,647, default value is 0
        long: 64bit integral value, from -2^63 to 2^63 - 1, default value is 0L, example value is 5106L
        float: 32bit floating value, default value is 0.0f, example value is 511.183f
        double: 64bit floating value, default value is 0.0, example value is 511.183
        char: 16bit unicode value, from 0 to 65,535, default value is \u0000, example value is 'C'
        => To keep in mind:
            in Java, boolean true and false are completely unrelated to 1 and 0
            all numeric types are signed (allow negative numbers)
            float requires f (or F) at the end
                float x = 2.7; // Does not compile
                float x = 2.7f; // OK
            long requires l (or and preferably L) at the end
                long a = 45366546327; // Does not compile
                long a = 45366546327L; // OK
            for readability the use of underscore (_) is allowed, but NOT in the beginning or the end
                int a = 1_000_000; // normal usage
                int b = 1_2; // OK, but not very useful
                int c = 1________2; // even less useful, but still OK
                double d = 1_000_000.000_001 // OK and makes sense
                double x = _10.1; // NOK, do not allowed underscore at the beginning or the end
    Wrapper classes:
        Primitives are not objects, and sometimes we prefer to work with objects
        Each primitive has a wrapper class
        The most common way to create an object from the primitive is
            use static method valueOf()
            Example:
                Integer a = Integer.valueOf(5);  //First Integer is class name, then a is the reference variable, then class static method valueOf() of class Integer, 5 is the int literal
            Table:
                        |   Primitive Type  |   Wrapper class   |            Example            |
                        |    boolean        |   Boolean         | Boolean.valueOf(true)   ;     |
                        |    byte           |   Byte            | Byte.valueOf((byte) 12);      |
                        |    short          |   Short           | Short.valueOf((short) 12);    |
                        |    int            |   Integer         | Integer.valueOf(12);          |
                        |    long           |   Long            | Long.valueOf(12L);            |
                        |    float          |   Float           | Float.valueOf(12.0F);         |
                        |    double         |   Double          | Double.valueOf(12.0);         |
                        |    char           |   Character       | Character.valueOf('c');       |
            valueOf() can be used to convert String into wrapper class
            Example:
                Integer a = Integer.valueOf("12");    //Create variable with wrapper class type
        Wrapper classes come with some useful methods
            Convert string to int primitive type:
                    int intNumber = Integer.parseInt("101");  //Create variable with primitive type
            And some other useful methods: byteValue(), shortValue(), intValue(), floatValue(), doubleValue(), booleanValue(), and charValue()
                Example:
                    Double d = Double.valueOf(314.67);
                    System.out.println(d.byteValue()); //Output is: 58  (wrap: 314 - 256 = 58)
                    System.out.println(d.intValue()); //Output is: 314
                    System.out.println(d.doubleValue()); //Output is: 314.67
13. Non-Primitive Types:
    Definition: These are more complex data types that are derived from primitive types. They can hold multiple values and are always objects.
    Characteristics:
            Variable size.
            Stored in the heap memory.
            Can represent collections of values or complex data.
            Can be null.
    Strings: are not primitive types in Java, but they are commonly use like primitive
            String greeting = "hello world";
            ......................
            ......................
            ...Tobe continued.....
14. Stack and Heap memory:
    Stack:
        Definition: The stack is a region of memory that stores temporary variables created by each method (function) call. It operates in a last-in, first-out (LIFO) manner.
        Characteristics:
                Storage of Local Variables: Stack memory is used for storing local variables, method parameters, and references to objects in the heap.
                Automatic Memory Management: Memory is automatically allocated and deallocated. When a method is called, a new block (frame) is created on the stack.
                                             When the method returns, its frame is removed.
                Limited Size: Stack memory is generally smaller than heap memory. Its size is defined at the start of the application and can lead to a StackOverflowError
                              if too much memory is used (e.g., in deep recursion).
                Fast Access: Accessing data from the stack is faster than from the heap due to its structured nature.
        Example:
            public class StackExample {
                public static void main(String[] args) {
                    int localVariable = 10;  // Stored in stack
                    anotherMethod();
                }

                public static void anotherMethod() {
                    int anotherVariable = 20; // Also stored in stack
                }
            }
    Heap:
        Definition: The heap is a region of memory used for dynamic memory allocation, where objects are stored. It is managed by the Java Virtual Machine (JVM).
        Characteristics:
                Storage of Objects: All Java objects and their instance variables are stored in heap memory.
                Dynamic Allocation: Memory can be allocated and deallocated dynamically at runtime using the new keyword.
                                    Unlike the stack, memory in the heap is not automatically freed when a method exits.
                Garbage Collection: The JVM includes a garbage collector that automatically reclaims memory used by objects that are no longer referenced,
                                    helping to prevent memory leaks.
                Larger Size: Heap memory is generally larger than stack memory, allowing more significant data storage.
                             However, accessing heap memory can be slower than stack memory due to the overhead of memory management.
        Example:
            public class HeapExample {
                public static void main(String[] args) {
                    MyObject obj = new MyObject(); // obj is a reference stored in the stack, new object of MyObject is in the heap
                }
            }

            class MyObject {
                int value;

                MyObject() {
                    value = 10; // Instance variable stored in heap
                }
            }
15. Text Blocks: Is a new feature in Java 15
    i.e
        The old way: String title = "\"Java Core\"\n    by Foden Duong";
        String title = """
            "Java Core"
               by Foden Duong""";
        //The output:
            "Java Core"
               by Foden Duong
    => Remember, after the first """, should be the new line
       and after the second """, can be the new line or the same line but recommended the new line if you want compiler to insert a new line
       Any whitespace before the first non-empty character in the line after the 1st """ will be ignored by compiler.
       Compiler looks for the first non-empty character.
       But once the compiler finds the first non-empty character, then these spaces (before by Foden Duong""") will be essential,
       so these are part of the string.
16. Variables: is a name for a piece of memory which stores data
    To declare a variable: int x;
    To initialize a variable: int x = 5;
    Name of the variable (method, class, interface, package, ...) is called identifier
    Identifier rules:
        Must begin with a letter, currency symbol ($, ...), or underscore(_)
        Can include numbers, but not start with a number
        Single underscore(_) is not allowed as an identifier
        You cannot use the reserved word (like: abstract, case, continue, super, import, return, volatile, goto,...)
    Naming conventions:
        For variables, use camelCase
        For constants, use SNAKE_CASE
        Identifier of classes, interfaces, enums records start with first uppercase letter (e.g MyClass, MyInterface, StudentRecord)
        Identifiers variables and methods start with first lowercase letter (e.g fullName, getFullName())
        => Java identifier are case-sensitive !!
    Multiple variables can be declared/initialized in a single line (bad practice, but it compiles)
        int x, y;
        String firstName = "Foden", lastName = "Duong";
        boolean v = true, w, z = false;
    but you  cannot mix types (cannot declare variables of different type in a single line)
        int x, String name; // DOES NOT COMPILE
        or
        int x,
            String name: // "This is same line, as Java seperate lines by semicolon (;)", so DOES NOT COMPILE
    Three kinds of variables:
        Local variable - exist only within the block of code { ... }
        Instance variables (fields) - defined within the specific instance of the object
        Class variables - belong to a class and is shared with all instances of the class(marked with keyword static)
    Instance and class variables don't require initialization
        In-case you don't initialize variable, java will assume the defaults values of their type (i.e for doubles type, the default value is 0.0)
    Local variables must be initialized before use
        public int doesNotcompile(){
            int a = 3;
            int b;
            return a + b; // DOES NOT COMPILE as we use b but do not initialize it yet
        }
        but
        public int doesCompile(){
            int a = 5;
            int b = 3;
            int c;
            return a + b; // COMPIlE because c is not initialized but it's never used
        }
    Be careful if initialization is within if-statement
            public void doesNotCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5; // might never be reached
                }
                System.out.println(a); // DOES NOT COMPILE, variable a might not have been initialized
            }
            but
            public void doesCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5;
                } else {
                    a = 2;
                }
                System.out.println(a); // COMPILE, because this variable a will be initialized one way or another
            }
    Final variables (constants)
        final int MAX_HEIGHT = 100;
        Final can be applied to a reference:
            final int[] MY_NUMBERS = new int[5];
            in this case, reference cannot be modified, but the content of the object can:
                        MY_NUMBERS[2] = 10; // OK
                        MY_NUMBERS = null; // DOES NOT COMPILE as you are trying to modified the reference
    Variable scope:
        Local variable: in scope from { to }
        Method parameters: in scope for the duration of the method
        Instance variable: in scope from declaration until the object is eligible for garbage collector
        Class variables: in scope from declaration until the program ends
17. Arguments and parameters in Java (Đối số và tham số trong Java):
    public void greeting(String message){ // message is parameter
        System.out.println(message);
    }
    greeting("Welcome to Java Core"); // Welcome to Java Core is argument
    => Tham số (parameter) được định nghĩa trong hàm
       Đối số (argument) là giá trị truyền vào khi gọi hàm
18. Call by value and call by reference:
    In Java, the distinction between call by value and call by reference is important to understand, especially when working with primitive types and objects.

    Call by Value
        In Java, all method arguments are passed by value. For primitive types (like int, float, etc.), a copy of the value is passed to the method.
        Changes made to the parameter do not affect the original variable.
        Example (Primitive Type):
            public class CallByValue {
                public static void increment(int x) {
                    x += 1;  // Changes the local copy only
                }

                public static void main(String[] args) {
                    int num = 5;
                    increment(num);
                    System.out.println(num);  // Output: 5 (original value remains unchanged)
                }
            }

    Call by Reference (for Objects)
        While Java does not support true call by reference, it passes object references by value.
        This means that a copy of the reference (pointer) to the object is passed.
        If you modify the object using this reference, the changes will be reflected in the original object.
        Example (Object Type):
            class MyClass {
                int value;
                MyClass(int value) {
                    this.value = value;
                }
            }
            public class CallByReference {
                public static void modify(MyClass obj) {
                    obj.value += 1;  // Changes the object referenced
                }
                public static void main(String[] args) {
                    MyClass myObj = new MyClass(5);
                    modify(myObj);
                    System.out.println(myObj.value);  // Output: 6 (original object is modified)
                }
            }
    Summary
    Call by Value: For primitives, a copy of the value is passed; changes do not affect the original variable.
    Call by Reference (for Objects): A copy of the reference to the object is passed; changes to the object affect the original object.
19. Local variable reference type:
        Example:
            var a = 5; //Compiler will automatically figure out the type of a is int based on the value you passed
            But
            var a = "Foden"; //DOES NOT COMPILE if put this line in the same scope of the above line. It means when the compiler figure out the type of variable,
                                we cannot reassign the type of it
            And we cannot use local variable reference type for null value
                var a = null; DOES NOT COMPILE
        Remember, var is not a reserved word (not like int, final,...), so we can create class, or method name Var
            public class Var {} //OK
            or
            var var = 5; //OK
            or
            Var var = new Var(); //OK
        Remember, it's only work for local variable
            public int sum (var a, var b){
                return a + b;
            } //DOES NOT COMPILE > as it is only work for local variable, not method variable
        Practical usage:
            Old way:
                ClassWithALongName myInstance = new ClassWithALongName();
                or
                ClientList<Client> clientList = new ClassWithALongName.getClientList();
            New way:
                var myInstance = new ClassWithALongName();
                or
                var clientList = new ClassWithALongName.getClientList();
20. Garbage Collection:
        All Java objects are stored in program's heap memory (aka free store)
        Garbage collection is just a process of automatically freeing memory on the heap
            By removing all the objects which are no longer reachable by the program (Objects are eligible for Garbage collection)
            This process is out of our control, it's for java to handle automatically
        There is a system method to force this process : System.gc(); // with this method you can suggest java to clean the heap
            But it's not guaranteed to do anything !! You can hope that Java will clean the heap, but you can not be guaranteed that Java will do anything
        Example:
            public class GcExample {
                public static void main(String[] args){
                    String a, b;
                    a = new String("Foden");
                    b = new String("Duong");
                    a = b;
                    String c = a;
                    a = null;
                }
            }
            Explain:
                        Reference (Stack memory)                    Object (Heap memory)
                    a ---------------------Reference a is pointed to object "Foden"-------------> "Foden"
                    b ---------------------Reference b is pointed to object "Duong"-------------> "Duong"
                    a = b, so now ---------Reference a is pointed to the object that is refered by b, that's "Duong"
                    now a is pointed to object "Duong" and no longer refered to "Foden",
                    then now "Foden" is eligible for Garbage collection and be removed from Heap memory
                    then String c = a -----c now is pointed to the object "Duong" which is also pointed to by a
                    then a = null, a no longer pointed to object "Duong" and now having value null
21. Operators
        There are 3 types of operators in Java:
            Unary operator: = Requires only one operator
                i++; Increases value by 1 and then return the OLD value
                    Example:
                        int a = 5;
                        int b = a++;
                        System.out.println(a); // = 6, because a++ increase value of a by 1
                        System.out.println(b); // still  = 5, because a++ increase value of a by 1, but return the OLD value, then it's 5
                ++i; Increases value by 1 and then return the NEW value
                    Example:
                        int x = 1;
                        int y = ++x*2
                        => y = (++x) * 2;
                        => y = 2 * 2
                        => y = 4;
            Binary operator:
                Addition: a + b;
                Subtraction: a - b;
                Multiplication: a * b;
                Division: a / b;
                Modulo operator: a % b;
                    Example:
                        11 / 2 = 5 (FLOOR value)
                        11 % 2 = 1 (Remainder of division)
                    Java promotes variable type, example:
                        short x = 5;
                        short y = 7;
                        System.out.println(x + y); // x and y are promoted to int, the result is int = 12
                        But
                        short z = x + y; //DOES NOT COMPILE as you try to put int to short
            Ternary operator:
                a = (b > 0) ? 3 : 4;
        Java automatically promotes smaller to larger data type
            Example:
                short x = 5;
                int y;
                y = x; //OK (x is casted to int )
            But can not do it in vice verse
            Example:
                int x = 5;
                short y;
                y = x; //DOES NOT COMPILE as you try to put int in short
                but, to have it work, you can cast type
                y = (short) x; //OK
        Expression a = 2 do 2 things:
            First, assign value 2 to a
            Second return value 2
            Example:
                int x = 5;
                int y = (x = 3) * 2;
                => x = 3; y = 6
        Favourite exam trick:
            boolean isOK = false;
            if(isOK = true){ // here the assignment operator = , not comparison operator == , so isOK is assigned to new value is true, the "true" will be printed out in the console
                System.out.println("true");
            } else {
                System.out.println("false");
            }
        Comparison operators
            Example:
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = name1;
                System.out.println(name1 = name2); //false because name1 and name2 are pointed to different object in the heap
                System.out.println(name1 = name3); //true because name1 and name3 are pointed to same object in the heap
22. Switch Statement:
        Default could be  anywhere in the block
        Be careful if there are no break statement:
            public void greeting(int a){
                switch(a){
                    case 1:
                        System.out.println("One");
                    default:
                        System.out.print("Maximum");
                    case 2:
                        System.out.print("Two");
                    case 3:
                        System.out.print("Three");
                }
            }
            greeting(5);// The results will be: Maximum Two Three, because there no break so after the default, it will execute all the case after default
23. Switch Expression:
        Java 8:
                    public void greeting(int a){
                        switch(a){
                            case 1:
                            case 2:
                            case 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Java 17:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Another improvement in Java 17, using -> instead of : then you don't need break statement anymore:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3 -> System.out.print("In first three int numbers");
                            case 4, 5, 6 -> {
                                System.out.println("In first three int numbers");
                                System.out.println("Multiple command should be placed in {}");
                            }
                            default -> System.out.print("Not in first three int numbers");
                        }
                    }
        Real improvements, Switch statement can be treated as an expression:
                String alarmMeAboutNumber = switch(a){
                              case 1, 2, 3 -> "In first three int numbers";
                              default -> "Not in first three int numbers";
                          }; // need ; at the end because this is expression returns a string
        We can use yield keyword (similar to return statement in methods)
                Example:
                    int a = 1;
                    String greeting = switch(a) {
                                        case 0, 1, 2 -> {
                                            String str1 = "Good";
                                            String str2 = " day";
                                            yield str1 + str2;
                                        }
                                        case 3, 4 -> "Hi";
                                        default -> "Hello";
                                       };
                    System.out.println(greeting); // output is : Good day
                Another example:
                    public void greet(int a, int b){
                        String greeting = switch(a) {
                            case 0 -> "Good morning";
                            case 1 -> {
                                if(b > 0) yield "Good morning";
                                    else yield "Good afternoon";
                            }
                            case 2 -> "Hi";
                            default -> "Hello";
                        };
                        System.out.println(greeting)
                    }
                    greet(1, -1); // output is : Good afternoon
        Switch expression can return different value types:
            Example:
                public void greet(int a){
                    var printOut = switch(a){
                        case 0 -> "Good morning" //String
                        case 1 -> 5; //int
                        case 2 -> true; //boolean
                        default -> 3.14 //double
                    }
                }
        Switch expression must handle all possible cases -> it means the DEFAULT statement is REQUIRED (except for enum case)
        If we use enums, we can just list all possible values
            Example:
                enum Compass {NORTH, SOUTH, EAST, WEST}
                String getDirection(Compass value){
                    return switch(value){
                        case NORTH -> "Up";
                        case SOUTH -> "Down";
                        case EAST -> "Right";
                        case WEST -> "Left";
                    }
                }
                System.out.println(getDirection(Compass.SOUTH));
24. While Loop
        Using break in nested loops, with labels: To stop outer loop in case you're in inner loop
            Example:
                int i = 0; j = 0;
                OUTER_LOOP: while(true){
                    i++;
                    j = 0;
                    INNER_LOOP: while(true){
                        j++;
                        System.out.print("(" + i + "," + j + ")");
                        if(j == 3) break OUTER_LOOP; //break will turn into label OUTER_LOOP, then the outer loop will be ended.
                                                     //Output is (1,1), (1,2), (1,3)
                    }
                }
        or
        use return; to terminate the method
            Example:
                public void printPairs(){
                    int i = 0; j = 0;
                    OUTER_LOOP: while(true){
                        i++;
                        j = 0;
                        INNER_LOOP: while(true){
                            j++;
                            System.out.print("(" + i + "," + j + ")");
                            if(j == 3) return; //exist the method
                        }
                    }
                }
                printPairs(); //Output is (1,1), (1,2), (1,3)
25. For Loop:
        Can omit any one of the statements but still have to keep ; in place
        Infinite loop
             for( ; ; ){}
        You can use more than one index in a for loop, separated by comma
            for(int i = 0, j = 0; (i + j) < 5; i++, j++) {
                System.out.println("i=" + i + ", j=" + j);
                //output;
                    i=0, j=0
                    i=1, j=1
                    i=2, j=2
            }
26. For-Each Loop:
        Is often used to access the members of array (or collection, when you don't need access the index of member actually)

27. String
    String is a sequence of characters, implementing CharSequence interface:
    String name = "Foden";
    String name = new String("Foden");
    Concatenation:
            str1 + str2
        or
            str1.concat(str2)
        If both operands are numeric, + mean addition
        If either operand is String, + means concatenation
        Evaluation is left to right -> System.out.println("Foden" + 4 + 6); //Output is Foden46
                                       System.out.println("Foden" + (4 + 6)); //Output is Foden10
        It's allowed to concatenation with null string -> System.out.println("Foden" + null); //Output is Fodennull
    String Methods:
        length():
                String name = "Foden"; -> System.out.println(name.length()); //Output is 5
        charAt():
                String name = "Foden Duong"; -> System.out.println(name.charAt(6)); //Output is D (index start from 0, so char at index 6 is D)
                                             -> System.out.println(name.charAt(17)); //Output is StringIndexOutOfBoundException
        indexOf():
                String name = "Doctor Dolittle";    -> System.out.println(name.indexOf('t')); //Output is 3, start finding from index 0, and return the first index of character what is being searched
                                                    -> System.out.println(name.indexOf('t', 5)); //Output is 11, because start to find from index 5, so the t at index 3 will be ignored
                                                    -> System.out.println(name.indexOf("cto")); //Output is 2 that is the index of first character of string "cto"
                                                    -> System.out.println(name.indexOf("Do", 4)); //Output is 7
                                                    -> System.out.println(name.indexOf("A")); //Output is -1 , means not found
        substring():
                String name = "Foden Duong";    -> System.out.println(name.substring(4)); //Output is n Duong (includes start index to the end of string)
                                                -> System.out.println(name.substring(4, 8)); //Output is n Du (includes start index but does not include end index)
                                                -> System.out.println(name.substring(4, 4)); //Output is (output is empty string)
                                                -> System.out.println(name.substring(8, 4)); //Output is IndexOutOfBoundsException
                                                -> System.out.println(name.substring(4, 14)); //Output is IndexOutOfBoundsException
        toLowerCase():
                String name = "Foden Duong"; -> System.out.println(name.toLowerCase()); //Output is foden duong
        equals(), equalsIgnoreCase():
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = new String("foden Duong");
                System.out.println(name1 == name2); //false, because they are not referencing to the same object
                System.out.println(name1.equals(name2)); //true, because same content
                System.out.println(name1.equals(name3)); //false, because String is case-sensitive
                System.out.println(name1.equalsIgnoreCase(name3)); //true, method equalsIgnoreCase will ignore case sensitive
        startsWith(), endsWith():
                String name = "Foden Duong";
                System.out.println(name.startsWith("F")); //true
                System.out.println(name.startsWith("Fod")); //true
                System.out.println(name.endsWith("g")); //true
                System.out.println(name.endsWith("Duong")); //true
                System.out.println(name.startsWith('F')); //DOES NOT COMPILE, because argument must be a string, not char !
        contains():
                String name = "Foden Duong";
                System.out.println(name.contains("n")); //true
                System.out.println(name.contains('n')); //DOES NOT COMPILE, because string implements CharSequence, single quotes for char do not create a CharSequence, then compile error.
                                                        //need to pass a string or a single charater within double quote ""
                System.out.println(name.contains("en D")); //true
                System.out.println(name.contains("m")); //false
        replace():
                String str = "abcdeabc";
                System.out.println(str.replace('c', 'y')); //Output is abydeaby (replaces all instances of 'c' with 'y')
                System.out.println(str.replace("c", "y")); //Output is abydeaby (parameters can be both string and char)
                System.out.println(str.replace("abc", "fod")); //Output is foddeabc
        strip(), trim(), stripLeading(), stripTrailing():
                String str = " abc ";
                System.out.println(str.strip()); //Output is abc (strip() removes whitespaces at the beginning and the end, also supports unicode whitespace. It is a recommended way to use in case wanna remove whitespace at beginning and the end)
                System.out.println(str.trim()); //Output is abc (works same as strip() but does not support unicode whitespace)
                System.out.println("|" + str.stripLeading() + "|"); //Output is |abc | (remove the whitespaces at the beginning)
                System.out.println("|" + str.stripTrailing() + "|"); //Output is | abc| (remove the whitespaces at the end)
        indent(n) method:
                If n = 0 does nothing
                If n > 0 adds the same number of blank spaces to each line
                If n < 0 tries to remove n whitespace characters from the beginning of line
                Normalizes existing line breaks
                Adds line break at the end if missing
        stripIndent() method:
                Removes all leading incidental whitespace
                Normalizes existing line breaks
                Does not add line break at the end if missing
                    Example for indent(n) and stripIndent():
                        String str = "  Foden\n Duong";
                        System.out.println(str); Output is:  Foden
                                                            Duong
                        System.out.println(str.indent(2)); //Add 2 whitespaces add the beginning of each line Output is:    Foden
                                                                                                                           Duong
                        System.out.println(str.indent(-2)); //Remove 2 whitespaces add the beginning of each line Output is:  Foden
                                                                                                                             Duong
                        System.out.println(str.stripIndent()); //Remove all whitespaces of line having total of whitespaces is min, and remove that of whitespace for other lines ,
                                                               //in this case remove all spaces at the beginning of line Duong, and remove total of that whitespaces in line Foden Output is: Foden
                                                                                                                                                                                             Duong
        translateEscapes():
                String name = "Foden\\tDuong";
                System.out.println(name); //Output is Foden\tDuong (first t supports to escapes second t, then \t will be printed out)
                but
                System.out.println(name.translateEscapes()); //Output is Foden Duong (translateEscapes() method will support to understand the \t, then \t will be treated as a tab)
        isEmpty(), isBlank():
                System.out.println("".isEmpty()); //true
                System.out.println(" ".isEmpty()); //false, because it is not empty
                System.out.println("".isBlank()); //true
                System.out.println(" ".isBlank()); //true
        String formating symbols:
                %s for any type, usualy for String
                %d for integral values (int and long)
                %f for decimal numbers (float and double)
                    Example:
                        String name = "Foden";
                        int numberOfMembers = 5;
                        String printOut1 = "Family of " + name + " has " + numberOfMembers + " members.";
                        String printOut2 = String.format("Family of %s has %d members.", name, numberOfMembers);
                        String printOut3 = "Family of %s has %d members.".formatted(name, numberOfMembers);
                        => The 3 ways above gives the same result.
        Method chaining:
                left -> right
                String name = " Foden Duong ";
                System.out.println(name.trim().toUpperCase().replace('F','M')); //Output is Moden Duong
                !!!Strings are immutable
                String name = "Foden Duong";
                name.toUpperCase();
                System.out.println(name); //Output is still Foden Duong, because string is immutable, so the original value of string will be kept the same
                But
                name = name.toUpperCase();
                System.out.println(name); //Output now is FODEN DUONG
        String builder:
                StringBuilder is a mutable class which contains a String
                It has many methods for manipulating the strings
                    Example:
                        StringBuilder name = new StringBuilder("Foden Duong");
                Some methods work in the identical way as with a normal String substring(), indexOf(), length(), and charAt()
                Methods:
                        1. append():
                                StringBuilder name = new StringBuiler("Foden");
                                name.append("Duong");
                                System.out.println(name); //Output is FodenDuong (name is changed now, so can say StringBuilder is mutable)
                           chaining with append():
                                name.append(1).append(true);
                                System.out.println(name); //Output is FodenDuong1true (all arguments are converted to String)
                        2. insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. "); //insert to index 5 the Mr.
                                System.out.println(name); //Output is Foden Mr. Duong
                           chaining with insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. ").insert(6, "A"); //be careful, the first insert() will be performed in the original string, but the second insert will be performed in the new string after the first insert completed
                                System.out.println(name); //Output is Foden AMr. Duong
                        3. delete():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.delete(1, 4)); //Output is Fn Duong (remove all characters from 1 to 4, but exclude 4)
                        4. deleteCharAt():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.deleteCharAt( 4)); //Output is Fod Duong (remove character at index 4)
                                System.out.println(name.deleteCharAt( 15)); //Output is StringIndexOutOfBound
                        5. replace():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.replace(0, 4, "Vinh")); //Output is Vinhn Duong (will replace string from 0 to index 4 - 1 = 3 by Vinh)
                                    If final index is too large, replace goes through the end (no exception !!)
                                        StringBuilder name = new StringBuilder("Foden Duong");
                                        name.replace(6, 100, "Vinh");
                                        System.out.println(name); //Output is Foden Vinh
                        6. reverse():
                                StringBuilder name = new StringBuilder("FODEN");
                                name.reverse();
                                System.out.println(name); //Output is NEDOF
                        7. toString():
                                StringBuilder name = new StringBuilder("FODEN");
                                String nameInString = name.toString();
                        8. equals():
                                => Remember StringBuilder doesn't implement equals() method, so if you use equals() for a string builder, it will treat as ==,
                                => then compiler will compare the references and if the reference is point to different object, it will be false
                                    Example:
                                        StringBuilder name1 = new StringBuilder("FODEN");
                                        StringBuilder name2 = new StringBuilder("FODEN");
                                        System.out.println(name1 == name2); //false
                                        System.out.println(name1.equals(name2)); //false as well, because StringBuilder doesn't implement equals() method, the it will treat equals() as ==
                                => !!! So if we want to compare content we have to convert it back to String:
                                        System.out.println(name1.toString().equals(name2.toString())); //Output is true
                        9. substring():
                                => StringBuilder is mutable class, but there is one exception: substring() returns a String and doesn't change the StringBuilder
                                        Example:
                                            StringBuilder name = new StringBuilder("Foden Duong");
                                            name.substring(6, 11);
                                            String subName = name.substring(6, 11);
                                            System.out.println(name); //Output is still Foden Duong (so StringBuilder.substring() is immutable - exception one)
                                            System.out.println(subName); //Output is Duong

28. String pool (or intern pool):
    When creating a new string with literal value "Foden", JVM stores it in the memory location known as String pool or intern pool (part of heap memory)
    Now creating a new string with same literal value "Foden", instead of creating a new memory spot for this literal value, JVM will look in the String pool,
        then it finds that literal already exists, it will point the new variable to the existing location in the String pool
    Example:
        String str1 = "Foden";
        String str2 = "Foden";
        System.out.println(str1 == str2); //true, because same content and point to the same location in String pool
        System.out.println(str1.equals(str2)); //true, equals only compare the content of these 2 strings
    But, tricky example #1
        String str1 = "Foden";
        String str2 = "   Foden  ".trim();
        System.out.println(str1 == str2); //false, because pool is created at compile-time, but trim() is evaluated at run-time
    Or even like this, it's still false
        String str1 = "Foden";
        String str2 = "   Foden  ";
        str2 = str2.trim();
        System.out.println(str2); //Output here is Foden, but the below line still getting false, because pool is created at compile-time, but trim() is evaluated at run-time
                                  //More explanation: During compile time, compiler will check 2 strings str1 = "Foden" and str2 = "   Foden  ", it sees that these 2 strings are
                                  //different, then it will assign them to 2 different memory spots in String pool, that's why even after trim(), str2 now is "Foden", but we still
                                  //get false when trying to compare str1 == str2
        System.out.println(str1 == str2);
    Tricky example #2
        String str1 = "Foden Duong";
        String str2 = "Foden" + " " + "Duong";
        System.out.println(str1 == str2); //true, because the concatenation is done in the compile-time
    There's way to get true in the tricky example #1: That is instruct the compiler to use the pool even with runtime methods
        String str1 = "Foden";
        String str2 = "   Foden  ".trim().intern(); //use intern() to tell the compiler that need to evaluate the trim() method
        System.out.println(str1 == str2); //true
29. Arrays
    Many ways to initialize an array:
            int[] nums = new int[3]; //declare first
            nums = new int[]{2, 1, 3}; //initialize later
        or
            int[] nums = new int[]{2, 1, 3};
        or
            int[] nums = {2, 1, 3};
    Can have multiple values in one declaration but not recommended:
            int[] nums, ages; // 2 arrays declared
        or
            int nums[], a; // 1 array and 1 int number declared
    Arrays don't implement equals() method, so if you use equals(), it will be treated as == comparison
    Printing out the array:
            int[] nums = {2, 1, 3};
            System.out.println(nums); //Output will something like this I@7a4f0f29, this is the hash code of reference nums.
        so to print out the array:
            System.out.println(Arrays.toString(nums)); //Output is [2, 1, 3]
    Every array has a property called length (It is a property, not a method)
            int[] nums = {2, 1, 3};
            System.out.println(nums.length); //Output is 3
    Methods of Arrays:
        Arrays.sort():
                int[] nums = new int[] {2, -4, 7, 17};
                Arrays.sort(nums);
                System.out.println(Arrays.toString(nums)); //Output is [-4, 2, 7, 17]
                => !!! Arrays are mutable,sort() changes the original array.
        Arrays.binarySearch():
                Works only on sorted arrays
                If array is not sorted, then the result is unpredictable
                This method takes array and array elements as arguments,
                    if element is found, the index of that element is returned
                    if element is not found, the negative number is returned -(index_where_it_would_belong + 1)
                Example:
                    int[] nums = new int[] {3, -1, 8};
                    Arrays.sort(nums); // sort array to have binarySearch() works, now array is {-1, 3, 8}
                    System.out.println(Arrays.binarySearch(nums, -1)); //Output is 0, the index of -1
                    System.out.println(Arrays.binarySearch(nums, 1)); //Output is -2, why ? if 1 exists in the array, then it should be index 1 => -(index_where_it_would_belong + 1) = -(1 + 1) = -2
        Arrays.compare():
                This method determines which array is smaller and returns:
                    Negative number if first array is smaller than second array
                    Zero number if the arrays are the same contents
                    Positive number if first array is larger than second array
                Definition of what is smaller here:
                    If one array has less number of elements than another, it's smaller
                    If both arrays have same number of elements:
                        Smaller is the one whose first different member is smaller
                        Example:
                            int[] nums = new int[] {3, -1, 8};
                            int[] nums1 = new int[] {3, -2, 8};
                            => then nums1 is smaller than nums
                        For Strings:
                            One is smaller if it is a prefix of another
                            Numbers are smaller than letters (i.e "232" is smaller than "Fo")
                            Uppercase is smaller than lowercase
                            Alphabetical order is applied
                    Null is smaller than any other values

                Some examples:
                    Arrays.compare(new int[]{3, 7}, new int[]{4}); => returns positive number, because first array has more elements than second one
                    Arrays.compare(new int[]{3, 7}, new int[]{3, 7}); => returns 0, because these 2 arrays has the same content
                    Arrays.compare(new String[]{"ab", "sdfs"}, new String[]{"abs", "shtr"}); => returns negative number, because first elements are different, can see "ab" is prefix of "abs",
                                                                                                then first array is smaller than second one
                    Arrays.compare(new String[]{"xy", "sdfs"}, new String[]{"abc", "shtr"}); => returns postive number, because first elements are different, can apply alphabetical order here,
                                                                                                because "x" is after "a", means "abs" is smaller than "xy", then means first array is larger than second array
                    Arrays.compare(new String[]{"Foden", "John"}, new String[]{"foden", "Duong"}); => returns negative number, because UpperCase is smaller than lowercase
        Arrays.mismatch():
                This method returns -1 if array are the same content, otherwise returns the first index where they differ
                Example:
                    Arrays.mismatch(new String[]{"Foden", "Duong"}, new String[]{"Foden", "Vinh"}); => return 1, that is the index of second element where they differ
    Multidimensional arrays:
        This is array of arrays:
        Example:
            int[][] a = {
                {-1, 3},
                {5},
                {45, 7, -2},
                {32, 6, 3, 11}
            }; => This array a has 4 elements type array, first element is an array has 2 element -1 and 3, ... so on
        Accessing elements with traditional loop:
            for(int i = 0; i < a.length; i++){
                for(int j = 0; j < a[i].length; j++){
                    System.out.println("a(%d, %d) = %d".formatted(i, j, a[i][j])); i is row, j is index in row = j is column
                }
            }
            The result like:
                a(0,0) = -1
                a(0,1) = 3
                a(1,0) = 5
                a(2,0) = 45
                ...........
        Accessing elements with for-each loop:
            for(int[] row : a){
                for(int column : row){
                    System.out.println("Element = " + element);
                }
            }
            The result like:
                Element = -1
                Element = 3
                Element = 5
                Element = 45
                ............
30. Dates and Times: Creating Date and Time, Methods on Dates and Times
            import java.time.*;  //If only use LocalDate, LocalTime, and LocalDateTime
            import java.time.temporal.*; //Import this one if you want to use chronounits
            public class DatesAndTimes {

                public static void main(String[] args) {
                    LocalDate localDate = LocalDate.now();
                    LocalTime localTime = LocalTime.now();
                    LocalDateTime localDateTime = LocalDateTime.now();
                    ZonedDateTime zonedDateTime = ZonedDateTime.now();
                    System.out.println(localDate);      //Output is: 2024-10-26
                    System.out.println(localTime);      //Output is: 22:46:33.977090400
                    System.out.println(localDateTime);  //Output is: 2024-10-26T22:46:33.977090400
                    System.out.println(zonedDateTime);  //Output is: 2024-10-26T22:46:33.978089600+07:00[Asia/Bangkok]

                    Creating local date: 2 ways
                            LocalDate d1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalDate d2 = LocalDate.of(2024, 10, 26);
                            System.out.println(d1); //Output is: 2024-10-26
                            System.out.println(d2); //Output is: 2024-10-26 (same as the way above using for creating d1)

                    Creating local time: Many ways to do that
                            LocalTime t1 = LocalTime.of(22, 52);
                            LocalTime t2 = LocalTime.of(22, 52, 38);
                            LocalTime t3 = LocalTime.of(22, 52, 38, 131);
                            System.out.println(t1); //Output is: 22:52
                            System.out.println(t2); //Output is: 22:52:38
                            System.out.println(t3); //Output is: 22:52:38.000000131

                    Creating local date-time: Many ways to do that
                            LocalDateTime dt1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 22, 55, 59); //yyyy, mm, dd, hh, mm, ss
                            LocalDate ld1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalTime lt1 = LocalTime.of(22, 55, 59);
                            LocalDateTime dt2 = LocalDateTime.of(ld1, lt1);
                            System.out.println(dt1); //Output is: 2024-10-26T22:55:59
                            System.out.println(dt2); //Output is: 2024-10-26T22:55:59 (same as above)

                    Creating zoned date-time:
                            ZoneId zoneId = ZoneId.of("Europe/Zagreb");
                            ZonedDateTime z1 = ZonedDateTime.of(2024, 10, 26, 23, 2, 19, 32,zoneId); //yyyy, mm, dd, hh, mm, ss, nano second, zoneId
                            System.out.println(z1); //Output is: 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb]
                             ==> +02:00 in the output means that the local time Europe/Zagreb is 2 hours ahead of UTC (Coordinated Universal Time) or aka GMT (Greenwich Mean Time)
                             ==> If UTC/GMT time is now 1PM, then at Europe/Zagreb it should be 3PM

                    For the exam, you need to know how to convert between time-zones:
                             ==> 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb] should be 2024-10-26T21:02:19.000000032 in UTC/GMT
                             ==> 2024-10-26T23:02:19.000000032-02:00[Europe/Zagreb] should be 2024-10-27T01:02:19.000000032 in UTC/GMT

                    Date-Time Methods:
                            LocalDate, LocalDateTime
                                plusYears(), plusMonths(), plusWeeks(), plusDays()
                                minusYears(), minusMonths(), minusWeeks(), minusDays()
                            LocalTime, LocalDateTime
                                plusHours(), plusMinutes(), plusSeconds(), plusNanos()
                                plusHours(), minusMinutes(), minusSeconds(), minusNanos()
                            LocalDate, LocalTime, LocalDateTime
                                isBefore(), isAfter()
                            Example:
                                    LocalDate date = LocalDate.of(2024, Month.OCTOBER, 26); //Output is: 2024-10-26
                                    date = date.plusDays(2); //Output is: 2024-10-28
                                    date = date.plusWeeks(1); //Output is: 2024-11-04 (calculate from 2024-10-28)
                                    date = date.plusMonths(4); //Output is: 2025-03-04
                                    date = date.plusYears(3); //Output is: 2028-03-04
                            We can do method chaining:
                                    LocalDateTime localDateTime1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 23, 45, 21);
                                    localDateTime1 = localDateTime1.minusDays(2).plusHours(4).minusSeconds(20); //Output is: 2024-10-25T03:45:01
                    Date and time classes are immutable !!!
                            isBefore(), and isAfter()
                                    LocalDate date1 = LocalDate.of(2024, 10, 26);
                                    LocalDate date2 = LocalDate.of(2024, 10, 27);
                                    System.out.println(date1.isBefore(date2)); //Output is: true
                }
            }
31. Dates and Times: Period, Duration, Instant
        Period can be used only with LocalDate and LocalDateTime:
                Period p1 = Period.ofYears(2); //Output is: P2Y    (P2Y stands for Period of 2 Years)
                Period p2 = Period.ofMonths(3); //Output is: P3M    (P3M stands for Period of 3 Months)
                Period p3 = Period.ofWeeks(1); //Output is: P7D    (P7D stands for Period of 7 Days = 1 Week)
                Period p4 = Period.ofDays(11); //Output is: P11D    (P11D stands for Period of 11 Days)
                Period p5 = Period.of(2, 0, 15); //Output is: P2Y15D (P2Y15D stands for Period of 2 Years, zero Month, and 15 Days)
        Periods are used with plus/minus on date:
                Period period = Period.of(1, 2, 5);
                LocalDate date = LocalDate.of(2024, 10, 26);
                date = date.plus(period); //Output is: 2025-12-31
                date = date.minus(period); //Output is: 2024-10-26 (calculate from 2025-12-31)
        Duration can be used only with LocalTime and LocalDateTime:
                Duration dr1 = Duration.ofDays(3);     //Output is: PT72H    (PT72H stands for Period of Time 72 Hours)
                Duration dr2 = Duration.ofHours(3);    //Output is: PT3H
                Duration dr3 = Duration.ofMinutes(45); //Output is: PT45M
                Duration dr4 = Duration.ofSeconds(25); //Output is: PT25S
                Duration dr5 = Duration.ofMillis(230); //Output is: PT0.23S
                Duration dr6 = Duration.ofNanos(2503); //Output is: PT0.000002503S
        Using chronoUnits:
                import java.time.*;
                import java.time.temporal.*;
                Duration dr1 = Duration.of(3, ChronoUnit.HALF_DAYS);  //Output is: PT36H
                Duration dr2 = Duration.of(3, ChronoUnit.DAYS);  //Output is: PT72H
                Duration dr3 = Duration.of(3, ChronoUnit.HOURS);  //Output is: PT3H
                Duration dr4 = Duration.of(45, ChronoUnit.MINUTES);  //Output is: PT45M
                Duration dr5 = Duration.of(30, ChronoUnit.SECONDS);  //Output is: PT30S
                Duration dr6 = Duration.of(240, ChronoUnit.MILLIS);  //Output is: PT0.24S
                Duration dr7 = Duration.of(2503, ChronoUnit.NANNOS);  //Output is: PT0.000002503S
        ChronoUnits can also be used to determine how far apart are two times:
                    LocalTime t1 = LocalTime.of(17, 20);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 3
                Another
                    LocalTime t1 = LocalTime.of(17, 46);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 2 (even less than 3hours only 1 minutes, but it's still be counted as 2)
                Another
                    LocalTime t1 = LocalTime.of(17, 30);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.MINUTES.between(t1, t2)); //Output is: 195
        Durations are used with plus/minus on time:
                LocalTime time = LocalTime.of(17, 30);
                Duration duration = Duration.ofMinutes(45);
                time = time.plus(duration); //Output is: 18:15
                Duration duration = Duration.ofMinutes(45);
                time = time.minus(duration); //Output is: 16:45
        Instants are used to record time-stamps in the application
                Instant now = Instant.now();
                System.out.println(now); //Output is: 2024-10-27T00:25:52.923779102Z  (Z at the end, stands for zone time, because you are recording time-stamps in the application,
                                                                                       and application is running on your local machine, then it should be in your time zone,
                                                                                       so that is why only Z here, and thre's no specific zone id was added afer Z)
                Example: Measure duration of the process
                    Instant before = Instant.now();
                    //... some time-consuming process
                    Instant after = Instant.now();
                    Duration duration = Duration.between(before, after);
                    System.out.println(duration.toMillis()); //Output is: 255  (in milli seconds)
        Converting ZoneTimeDate to instant:
                ZoneId zone = ZoneId.of("Euro/Zagreb");
                ZonedDateTime z = ZonedDateTime.of(2024, 10, 27, 00, 33, 35, 145, zone);
                Instant instant = z.toInstant(); //Output is: 2024-10-27T00:33:35.000000145Z
32. Local and Instance variables:
        Local variables:
            Defined inside the block of code { }
            Can have only one optional modifier: final
                Once final variable is assigned a value it cannot be changed
            Effectively final: doesn't change value in the scope
                Variable is effectively final if you can put final in variable declaration and the code will still compile
            All local variables must be explicitly initialized before used
        Instance variables:
            Defined on class level, belong to instance of the class
            Can have different access modifiers: private, protected, public
            Can be marked as final, volatile, transient
            If not initialized, they assume default values depending on type
        Example of Local and Instance variables:
            class Item{
                public double tax = 0.2;  //Instance variable
                public double getPrice(double inputPrice){  //inputPrice is just a parameter for method
                    double margin = 0.05;  //Local variable
                    return inputPrice * (1 + tax) * (1 + margin);
                }
            }
            public class ItemHandlerPackage.ItemHandler{
                public static void main(String[] args){
                    Item item = new Item();  //Item item: item is a local variable
                    System.out.println(item.getPrice(100));
                    Item specialItem = new Item();  //Item specialItem: specialItem is a local variable
                    specialItem.tax = 0.1;  //Setting a new value for the instance variable tax of instance specialItem
                    System.out.println(specialItem.getPrice(100));
                }
            }
        Final variable:
            Whenever you defined a final variable, it needs to be initialized a value !!!
                    public double getPrice(double inputPrice){
                        double final margin;
                        margin = 0.05;
                        return inputPrice * (1 + tax) * (1 + margin);
                    }
            final means that variable reference is constant: the content can be modified, but the reference has to be constant
                    public void printSomething(){
                        final int[] a = {2, 5, 4};
                        a[1] = 3;  //OK , because we are changing the content not changing the reference
                        System.out.println(Arrays.toString(a));  // [2, 3, 4]
                        a = null; //DOES NOT COMPILE, because we are trying to change the reference
                    }
33. Variable  Arguments (Varargs):
        Helps method can accept any number of parameters of the same type
        Two rules to keep in mind:
            A method can have at most one varargs argument
            varargs argument must be the last parameter in the parameter list
        Example:
                public void greet(String greeting, String... names){
                    for(String name : names){
                        System.out.println(greeting + ", " + name + "!");
                    }
                }
                greet("Hello", "Foden", "Vinh"); //Output is: Hello, Foden!\n Hello, Vinh!
        You can pass an array as varargs
                String[] allMyNames = {"Foden", "Duong"};
                greet("Hello", allMyNames); //Output is the same: Hello, Foden!\n Hello, Vinh!
        You can NOT pass an array as varargs
                greet("Hello", {"Foden", "Duong"}); //DOES NOT COMPILE, because you are passing an anonymous array
            but
                greet("Hello", new String[] {"Foden", "Duong"}); //OK, because it's not an anonymous array ==> But this way is not recommended
        You can use varargs to write the main() method
                public static void main(String... args){}  //OK
34. Access modifiers: (src/main/java và src/test/java is just an organizational structure for source code and does not affect package identification
                       means if a class is created directly under src/main/java, and a class created directly under src/test/java, they're in the same package,
                       unless you create a package under these directories)
        private
            method or field can be accessed only within the class in which they are declared
        default (no keyword, means package-private)
            method or field can be accessed only within the same package
        protected
            method or field can be accessed within the same package and outside the package through child class
            means other class outside the package can only access protected method or field by extends the class, if you create instance of class instead of extends class,
            you can not access the method or field protected
        public
            method or field can be accessed from everywhere in the program
        Example: public, private
                class Dog{
                    private String genus = "Canis";
                    public void printGenus(){
                        System.out.println("Genus: " + genus);
                    }
                }
                public class MyClass{
                    public static void main(String[] args){
                        Dog dog = new Dog();
                        System.out.println(dog.genus); //DOES NOT COMPILE
                        dog.printGenus(); //OK, output is: Genus: Canis
                    }
                }
        Example:
                //Dog.java
                package zoo.dogs
                class Dog{
                    protected String genus = "Canis";
                }
                //Husky.java
                package zoo.huskys
                public class Husky extends Dogs{
                    public static void main(String[] args){
                        Husky husky = new Husky();
                        System.out.println(husky.genus); //OK, output is: Genus: Canis
                    }
                }
35. Static Members
        Static fields, and static methods don't belong to the instance of the class, but rather to class itself
            Example:
                    class Item{
                        public static double tax = 0.2;  //static mean tax belongs to the class Item, not to any instance of the class Item
                        public double getPrice(double inputPrice){
                            double margin = 0.05;
                            return inputPrice * (1 + tax) * (1 + margin);
                        }
                    }
                    public class MyClass{
                        public static void main(String[] args){
                            Item item1 = new Item();
                            System.out.println(item1.getPrice(100));  //Output is: 126.0
                            Item item2 = new Item();
                            item2.tax = 0.1;  //Because tax is static, this statement will change the value of tax for all instances of the class
                            System.out.println(item2.getPrice(100));  //Output is: 115.50000000000001       (tax used here has value 0.1)
                            System.out.println(item1.getPrice(100));  //Output is: 115.50000000000001       (tax used here also has value 0.1)
                        }
                    }
        Static members can be accessed directly, you don't need to create an instance of the object to access them
                class Dog{
                    public static void barks(){
                        System.out.println("Woof!");
                    }
                }
                public class MyClass{
                    public static void main(String[] args){
                        Dog.barks();
                        or you can also create instance then access it if you want
                        Dog dog = new Dog();
                        dog.barks(); //OK, but not recommended
                    }
                }
        Static methods can only call static fields directly
            Examples: with some problems to understand the context
                public class MyClass{
                    String hi = "Good afternoon!";
                    public static void greet1(){
                        System.out.println("Hello!");
                    }
                    private static void greet2(){
                        System.out.println(hi); //DOES NOT COMPILE, because method greet2() is static, and it's calling the variable hi which is non-static, it's not allowed by compiler
                                                //To fix, there are 3 ways, first way is make hi static. The second one is access via new instance of class: System.out.println(new MyClass().hi);
                                                //The third one is create a static instance of class, and use it at all:
                                                        public class MyClass{
                                                            String hi = "Good afternoon!";
                                                            static MyClass myClass = new MyClass();
                                                            .......................................
                                                            public static void greet2(){
                                                                System.out.println(myClass.hi);
                                                            }
                                                            ...................................
                                                        }

                    }
                    private void greet3(){
                        System.out.println("Good day!");
                    }
                    public static void greetAll(){
                        greet1();
                        greet2();
                        greet3(); //DOES NOT COMPILE, because method greetAll() is static, and it's calling the method greet3() which is non-static, it's not allowed by compiler
                                  //To fix, there are 3 ways same above
                    }
                    public static void main(String[] args){
                        MyClass.greetAll();
                    }
                }
        Constants:
            Are usually marked static final and written in SNAKE_CASE
                Example:
                        public class Item(){
                            public static final double VALUE_ADDED_TAX = 0.25;
                        }
            static final fields must be initialized before use, this could be done in a static block
                Example:
                        public class Item(){
                            public static final double VALUE_ADDED_TAX;
                            static{  //static block will be evaluated only once, when class is loaded to jvm for running,
                                     //means static block will be evaluated only when you invoke any static method of class, or create new instance of the class in which static block is located
                                VALUE_ADDED_TAX = 0.25;
                            }
                            public double calculatePrice(double price){
                                return price + price * VALUE_ADDED_TAX;
                            }
                        }
        static imports
            Are used to import static members of classes
                Example:
                    import java.lang.Math.pow;
                    ..........................
                    System.out.println(Math.pow(2,3)); //Output is 8
                    ..........................
                So if in your code, you need to simplify Math.pow(2,3) in case you repeatedly use it in the entire source code, you can do the static import
                    import static java.lang.Math.pow;  //the keyword `import` must be at the beginning of the line
                    .................................
                    System.out.println(pow(2,3)); //Now it's shorter
                    .................................
36. Boxing and Unboxing
        Boxing:
            Is a process of converting a primitive into its wrapper class (putting primitive in the box)
        Unboxing:
            Is a process of converting a wrapper class to a primitive (getting primitive out of the box)
            Explicit:
                Example:
                    int a = 4;
                    Integer b = Integer.valueOf(a);  //Convert int to Integer ==> boxing
                    int c = b.intValue();  //here a is the instance of wrapper class Integer, Convert wrapper to int ==> unboxing
            Implicit:
                Example:
                    int a = 4;
                    Integer b = a;  //Convert int to Integer ==> boxing (AutoBoxing)
                    int c = b;  //Convert wrapper to int ==> unboxing
        To remember:
            As you may know Java will autocast (auto casting) a smaller primitive into the larger one
            But Java will not do both automatic operations (autocast and autoboxing) at the same time!!!
            Example:
                int a = 3;
                long b = a; //Since int is a smaller primitive than long, then a will be auto-casted to long ==> OK
                but
                Long c = a; //DOES NOT COMPILE, because java will not perform autocast and autoboxing at the same time
                but
                Long c = Long.valueOf(a); //OK, because you explicit boxing here, java will only need to do one autocast operation
                and also
                Long c = (long) a; //OK, because you cast a from int to long, java will only need to do one autoboxing operation
                and also
                Long c = Long.valueOf((long) a); //OK, you cast a from int to long, and explicit do boxing here, then java doesn't need to do any automatic operation
            Another tricky example:
                Long a = 10; //here without L at the end, java will treat a as int number with value = 10 ==> DOES NOT COMPILE, because both autocasting and autoboxing is required here
                but
                Long a = 10L; //OK, java only need to perform autoboxing here
37. Method overloading
        Method overloading in Java allows you to define multiple methods with the same name but different parameters (different types, different total number of parameters, or order of parameters)
        Example:
                class MathOperations {
                    // Method to add two integers
                    public int add(int a, int b) {
                        return a + b;
                    }
                    // Overloaded method to add three integers
                    public int add(int a, int b, int c) {
                        return a + b + c;
                    }
                    // Overloaded method to add two doubles
                    public double add(double a, double b) {
                        return a + b;
                    }
                    // Overloaded method to add an integer and a double
                    public double add(int a, double b) {
                        return a + b;
                    }
                }
                public class Main {
                    public static void main(String[] args) {
                        MathOperations math = new MathOperations();

                        // Calling the different overloaded methods
                        System.out.println("Sum of two integers: " + math.add(5, 10)); // Calls add(int, int)
                        System.out.println("Sum of three integers: " + math.add(5, 10, 15)); // Calls add(int, int, int)
                        System.out.println("Sum of two doubles: " + math.add(5.5, 10.5)); // Calls add(double, double)
                        System.out.println("Sum of an integer and a double: " + math.add(5, 10.5)); // Calls add(int, double)
                    }
                }
        To remember:
            In passing argument doesn't exactly match the parameter type, java will pick the most similar version of the method
                    Example:
                        public void greet(int x) { System.out.println("parameter is int type"); }
                        public void greet(double x) { System.out.println("parameter is double type"); }
                        public void greet(int x, int y) { System.out.println("parameter is int type with 2 arguments"); }
                        short a = 2;
                        greet(a); //Output is: parameter is int type
                    Explanation:
                        When a short is passed to method greet(), Java first looks for a method that accepts an short parameter, if no such method exists, java will looks for larger primitive type is int, then long, ... and so on
                        with the list of Automatic Promotions as below:
                                byte → int, long, float, double     //For example, this one if java cannot find exact match for method with byte parameter, then will looks for a method accepts int, if still no, then long,... and so on
                                short → int, long, float, double
                                char → int, long, float, double    // You may be confused here, how char is promoted to int :D, char c = 'A'; // 'A' has a Unicode value of 65
                                                                                                                                int j = c;    // j now holds the value 65
                                                                                                                                System.out.println(j); // This will print 65
                                int → long, float, double
                                long → float, double
                                float → double
                    Another tricky example:
                               public void greet(Short a) { System.out.println("parameter is an instance of Short wrapper class"); }
                               public void greet(Integer a) { System.out.println("parameter is an instance of Integer wrapper class"); }
                               public void greet(String str) { System.out.println("parameter is an instance of String wrapper class"); }
                               public void greet(Object obj) { System.out.println("parameter is object type"); }
                               greet(2.3); //Java looks for a method with primitive type double, but you can see all of 4 methods above are not accepting any primitive parameter
                                           //So now Java will perform auto boxing, and it will convert double primitive into Double wrapper class
                                           //And then since there is NO greet() method which takes the instance of the wrapper class Double as a parameter
                                           //Java will try to find a superclass of the class Double, so this should be Object class (You already know every class in Java will automatically be a subclass of class Object)
                                           //So the method public void greet(Object obj) will be call here
                                           //Then Output is: parameter is object type
                               but
                               greet((short) 2); //Java looks for a method with primitive type short, but you can see all of 4 methods above are note accepting any primitive parameter
                                                 //So now Java will perform auto boxing, and it will convert short primitive into Short wrapper class
                                                 //Then Java found a method which accepts an instance of wrapper class Short as a parameter, which is public void greet(Short a)
                                                 //Then Output is: parameter is an instance of Short wrapper class
                    Another tricky example:
                            As you may know in the example above, after Java autoboxing primitive to wrapper class, then if it still cannot find any methods that accepts exact instance of wrapper class as a parameter
                            java will looks for a method accepts an object (because Object is actually a super class of every class in Java)
                            But
                            before Java looks for a method accepts an object, like an example above
                            java will looks for supertypes before looking for method accepts an object when it tries to determine which method to run
                                    public void greet(Number a) { System.out.println("Number abstract class here for a tricky example"); } //Number is an abstract class
                                                                                                                                           //and all other wrapper classes (except for String) which you get from your primitives,
                                                                                                                                           //they extend this abstract class Number
                                    public void greet(CharSequence a) { System.out.println("CharSequence interface here for a tricky example"); } //CharSequence is an interface
                                                                                                                                                  //and wrapper class String implements this interface CharSequence
                                                                                                                                                  //so we can say `CharSequence is a supertype of String`
                                    public void greet(Object obj) { System.out.println("Object class here for a tricky example"); }
                                    greet(3.14); //Since 3.14 is a double with primitive type, java will looks for a method which accepts exactly this primitive type first
                                                 //If there is NO, then this primitive double will be wrapped into wrapper class double
                                                 //And then since there is NO greet() method which takes an instance of wrapper class Double as a parameter
                                                 //Java will looks for the super type.
                                                 //Since Number is supertype of Double, then the method will be executed is
                                                 //public void greet(Number a)  ==> Output is: Number abstract class here for a tricky example
                                    greet("Foden"); //same above
                                                    //wrap "Foden" to String, which implements CharSequence ==> executed method: public void greet(CharSequence a) ==> Output is: Number abstract class here for a tricky example
                                    greet(new int[] {2, 1, 3}); //method public void greet(Object obj) will be executed ==> Output is: Object class here for a tricky example
            You cannot overload array with varargs !!!
                    Example:
                            public int doSomething(int[] nums) {  };
                            public int doSomething(int... nums) {  }; //DOES NOT COMPILE,
                                                                      //Because if you call method like this doSomething(new int[] {2, 1, 3});
                                                                      //It is impossible for Java to know which of these two methods to call, because it could be both
        In conclusion
                The order Java uses for finding the right overloaded methods:
                    Exact match by type
                    Larger primitive type
                    Autoboxed type
                    Supertype
35. Inheritence:
            Subclass can inherit members not private (fields and methods) from super class
            Java only supports single inheritance - Means class can only one direct superclass
      One class can implement multiple interface
      Class modifiers:
            final
          abstract
          static
          sealed     (java 17 or later)
          non-sealed (java 17 or later)
            All Java classes implicitly inherit from java.lang.Object class
      java.lang.Object class is the only class which doesn't have a parent class
      Every class has access to methods defined in Object class (e.g toString(), equals(), hashCode(), etc.)
36. Creating Classes:
            Keyword "this" is used to access the members of the class you're in
        Example:
            //Dog.java class
          public class Dog{
            private String name;
            protected int age;
            public void setAge(int age){
                this.age = age; //this.age to access the instance variable age of Dog class
            }
          }
      Setter method without using "this" in-case parameter name of method and instance field name are different
        Example:
            public void setAge(int theAge){
            age = theAge
          }
            Setter method using "this"
        Example:
            public void setAge(int age){
            this.age = age;
          }
            Keyword "super" is used to access the members of the superclass
        Example1:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Dog myDog = new Dog();
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
            Dog barks
        Example2:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Animal myDog = new Dog(); //create instance myDog type reference Animal, but it's still the object of Dog class,
                                                                //so it will still call sound() method in Dog class
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
            Dog barks
        Example3:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Animal myDog = new Animal(); //create instance myDog of Animal class
                                                                //so it will call sound() method in Animal class
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
        Example4:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Dog myDog = new Animal(); //DOES NOT COMPILE, because you cannot assign a parent class object to a child class reference
                                                                //this is because a parent class does not have all the attributes and methods that might be present in a child class
                                        //then making it an invalid assignment
              myDog.sound();
            }
          }
        Example5:
            //Mammal.java class
          public class Mammal{
            private int age;
            protected String name;
            public void setAge(int age){
                this.age = age;
            }
            public int getAge(){
                return this.age;
            }
          }

          //Dog.java class
          public class Dog extends Mammal{
            //setNameAndAge method without using "super"
            protected void setNameAndAge(String dogName, int age){
                name = dogName;
              setAge(age);
            }
            //setNameAndAge method using "super"
            protected void setNameAndAge(String name, int age){
                super.name = name; //because instance name in parent class has same name as method parameter
                                                 //so need to use super.name to indicate that the name belongs to parent class
              setAge(age);
            }
          }
37. Creating Constructors
            Special methods which are called everytime you created an instance of an object
      Name of the constructor must match the name of the class
      Constructor don't have a return type !!!
            If the return type is stated, than it's just a normal method (name of method has the same name as class - Valid case but not recommended)
      Constructor overloading
            Example:
              public class Dog{
                private String name;
                private int age;
                public Dog() { System.out.println("Woof!"); }
                public Dog(String name, int age){
                  this.name = name;
                  this.age = age;
                }
                public Dog(String name) { this.name = name; }
                public Dog(int age) { this.age = age; }
                public Dog(boolean isPuppy, String name){
                  this.age = isPuppy ? 0 : -1;
                  this.name = name;
                }
                //Main method:

          }
            Constructors are usually made public
        But you can also make them protected, default or private
      Private constructors are used if you don't want public no-argument constructor to be generated by the compiler
        In this case, the instance is usually created via some static method, and not using the keyword new
        We have seen this behaviour in classes used to create Dates and Times
                LocalDate now = LocalDate.now(); //We cannot create instance like LocalDate now = new LocalDate();
                                                                             //This is because LocalDate class has a private constructor
                                                                                         //So in this case, instance is created when we call the static method now()
38. Using this() and super() keywords
            Special method this() is used to call another constructor in a constructor
                    Example:
                        public class Dog{
                          private String name;
                          private int age;
                          public Dog(String name, int age){
                            this.name = name;
                            this.age = age;
                          }
                          public Dog(){
                            this("Chip", 1); //this will call constructor public Dog(String name, int age)
                            System.out.println("Woof!");
                          }
                          public static void main(String[] args){
                            Dog dog = new Dog();
                            System.out.println("Name: " + dog.name + ", " + "Age: " + dog.age);
                            //Output is:
                                                        Woof!  (this is printed first, because this is printed out statement,
                                              so it will be executed first when obj instance is created, then this("Chip", 1) will be executed later)
                                  Name: Chip, Age: 1
                          }
                        }
                    There are several rules when using this()
                            this() can only be called in the first line in the constructor
                            this() can be called only once
                    becareful when create a "cycle", example constructor 1 uses this() to call constructor 2,
                                                     then constructor 2 use this() to call constructor 3,
                                                     ...becareful it can direct you to an infinite loop, then breaks your code 😃
                            Example1:
                                    public Dog(){
                                        System.out.println("Woof!");
                                      this("Chip", 1); //DOES NOT COMPILE, because this() must be called in the first line in the constructor
                                    }
                            Example2:
                                    public Dog(){
                                        this();  //constructor no-arg calls itself, then it will be in an infinite loop
                                                     //====> Then eventually a stack overflow error will be thrown
                                      System.out.println("Woof!");
                                    }
                            Example3:
                                    public Dog(){
                                        this("Chip", 1); //Call constructor below
                                      System.out.println("Woof!");
                                    }
                                    public Dog(String name, int age){
                                        this();  //Again call constructor above, then again call... ==> will be a cycle (infinite loop) ==> Stack Overflow Error
                                      this.name = name;
                                      this.age = age;
                                    }
            Special method super() is used to call a constructor of a superclass in a constructor of the subclass
                    Example:
                            //Mammal.java class
                            class Mammal{
                                public int age;
                              public Mammal(int age){
                                this.age = age;
                              }
                            }
                            public class Dog extends Mammal{
                                private String name;
                              public Dog(String name, int age){
                                super(age); //Call constructor of super/parent class
                                this.name = name;
                                System.out.println("Woof!");
                              }
                            }
                    Rules for using super()
                            If there is NO explicit this() or super() in the first line of the constructor
                                the compiler will insert super() at the beginning of EVERY constructor
                            Can be called only once (means everyone constructor in subclass can only call super() 1 times)
                            Must be called in the first line of the constructor
                            !!!If there is NO this() or super() in the first line, then the compiler will insert super() automatically
                                    Example:
                                        class Mammal{
                                        public int age;
                                      }
                                      public class Dog extends Mammal{
                                        private String name;
                                        public Dog(){
                                            ==>!!!because there's no this() or super() here,
                                          ==>  so compiler will insert the call for special method super()
                                          ==>  to call constructor no-arg of super class
                                          System.out.println("Woof!");
                                        }
                                      }
                            Be careful if the superClass doesn't have the no-argument constructor
                            Example:
                              class Mammal {
                                    private int age;
                                    public Mammal(int age){
                                        this.age = age;
                                    }

                                }
                              public class Main extends Mammal{
                                    public Main(){
                                            ==> DOES NOT COMPILE
                                        ==> Because in here there is NO super() or this(), then compiler will insert no-arg constructor of super class to here
                                        ==> But you can see in the super class Mammal, a constructor with parameter a is defined already public Mammal(int a) { this.age = age; }
                                        ==> So the default no-arg constructor will NOT be created, then when compiler trys to insert no-arg constructor to constructor of subclass
                                        ==> It cannot, because no-arg doesn't exist in super class, so that compilation error will be thrown in this case
                                        System.out.println("Test");
                                    }
                                    public static void main(String[] args){
                                        Main main = new Main();
                                    }
                                }
39. Initializing Objects
            Order of initialization
                What happens when we initialize a class?
                        If there is a superclass, it is initialized first
                        All static variables are processed (in order of appearence)
                        All static initializers are processed (in order of appearance)
                        ==> This all happens at most once for each class!!
            Class is initialized automatically if main() method is inside the class,
                or manually by calling "new ClassName();"
            Example:
                  class Mammal{
                      static { System.out.println("Hello."); }
                  }
                  public class Dog extends Mammal{
                    public static void main(String[] args){
                        System.out.println("Good afternoon.");
                      new Dog();
                      new Dog();
                    }
                    static { System.out.println("Woof!"); }
                  }
                  //Output is:
                    Hello.
                    Woof!
                    Good afternoon
                  //Explanation:
                        Main method inside class Dog, so class Dog will be initialized
                      Class Dog has superclass Mammal, so class Mammal will be initialized first
                      Then static block inside superclass Mammal will be initialized,
                      Then static block in side class Dog will be initialized
                      Then System.out.println() statement in main method will be called
                      Then new Dog(); new Dog(); makes no effect, because the rule above "This all happens at most once for each class!!"
            final instance variables must assume the value by the time the constructor completes !
            final local variables must have value only if used
                        public class Item{
                            private final double tax;
                            private final double price;
                            public Item(){
                                this.price = 12.5;  //assignment in the constructor
                            }
                            { tax = 0.2 }  //assignment in the instance initializer
                        }
                        ==> This is OK, because the instance initializer is processed before constructor.
                            but if we don't assign the value for tax and price, it will be compile error
        Order of initialization when creating an instance
            What happens when we initialize an instance of a class?
                            Initialize the class if it was not already initialized (mentioned in the above section)
                            If there is a superclass, initialize superclass
                            Process all instance variable declarations
                            Process all instance initializers
                            Initialize the constructor
            Example:
                class Mammal{
                    static { System.out.println("Hello!"); }
                    { System.out.println("Good afternoon"); }
                }
                public class Dog extends Mammal{
                    private String name = "Foden";
                    { System.out.println("Name: " + name); }
                    private static int i = 0;
                    static { System.out.println(i); }
                    {
                        i++;
                        System.out.println(i);
                    }
                    public Dog(){
                        System.out.println("I am in the constructor of Dog class!");
                    }
                    public static void main(String[] args){
                        System.out.println("I am the main one.");
                        Dog dog = new Dog();
                    }
                }
                //Output:
                        Hello!
                        0
                        I am the main one.
                        Good afternoon
                        Name: Foden
                        1
                        I am in the constructor of Dog class!
                //Explanation:
                1. Because main() method inside Dog class, then class Dog will be initialized
                    but Dog class has super class Mammal, so Mammal class will be initialized
                2. static block in class Mammal will be executed first, then private static int i = 0; in the subclass
                    will be executed second, then the static block in the subclass Dog will be executed.
                3. then go back to the main() method, the System.out.println("I am the main one."); will be executed
                4. then execute line Dog dog = new Dog(); so now follow `What happends when we initialize intance of a class`
                    ,process all instance variable declarations, so private String name = "Foden" in subclass Dog will be processed
                    ,then process all instance initializers, so initializer block { System.out.println("Good afternoon"); } in Mammal class will be processed
                    ,then 2 initializer blocks in subclass will be processed { System.out.println("Name: " + name); } and   {
                                                                                                                                i++;
                                                                                                                                System.out.println(i);
                                                                                                                            }
                5. Finally, initialize the constructor, then the System.out.println("...") statement inside constructor will be executed.
40. Inheriting Members
        Inheriting Methods
                subclass can override an inherited method
                    subclass declares a new implementation for an inherited method
                    with same signature (name & parameters)
                    and covariant return type
                the property of the object to take many different forms is called polymorphism
                Example:
                    class Mammal{
                        public Mammal speak(){
                            System.out.println("Mammal is making a sound.");
                            return this;
                        }
                    }
                    public class Dog extends Mammal{
                        @Override  //This annotation is optional
                        public Dog speak(){   //The return type of speak() method in class Mammal is Mammal,
                                              //but the return type of the speak() method of Dog class is Dog.
                                              //Both methods have different return type but it is method overriding. This is known as covariant return type
                            System.out.println("Woof!");
                            return this;
                        }

                        public static void main(String[] args) {
                            Mammal mammal = new Mammal();
                            Dog dog = new Dog();
                            mammal.speak();
                            dog.speak();
                        }
                    }
                Method Overriding Rules: When you put the @Override, you need to follow the following rules
                    Overriden method must have the same signature as superclass method
                    Overriden method must be at least as accessible as the original method
                        it means if method in super class is public, when you override you cannot make it less accessible by using protected => it's not allowed in Java
                    Overriden method may not declare a checked exception that is new or broader than the one in original method
                        it means if method in super class is explicitly declared will throws IOException,
                            then in the method of subclass, we cannot explicit it to throws Exception, because Exception is broader than IOException
                            but you can do explicit it to throws FileNotFoundException, because FileNotFoundException is subclass of IOException
                    Return type of overriden method must be the same or a subtype of the return type of the original method (covariant return types)
                Example:
                    Case Exception:
                        //checked exception FileNotFoundException is subclass of IOException
                        class A{
                            public void greet() throws IOException{}
                            public void sayHello(){}
                            public void leave(){} throws FileNotFoundException
                        }
                        public class B extends A{
                            public void greet() throws FileNotFoundException //OK because FileNotFoundException is subclass of IOException
                            public void sayHello(){} throws IOException //NOT OK, becasue the method in superclass isn't declared to throws any exception
                            public void leave(){} throws IOException //NOT OK, because you are trying to declare a checked exception that is broader than the original one
                        }
                Overriding private and static methods
                    If the method is private, it's not visible to other classes, if we have a private method in superclass
                        then the method with same signature in subclass is independent of that method,
                        means this is not overriding, it's just completely different method
                    If the method is static, "overriden" method must also be declared static,
                        and also actually this is "not overriding", since every method belongs to its own class
                        this is called "hiding" the method
                    Method marked as final cannot be overriden nor hidden
                        Example:
                            //hiding a static method
                            class A{
                                public static void greet() { System.out.println("Hello"); }
                            }
                            public class B extends A{
                                public static void greet() { System.out.println("Good afternoon."); }  //Here if you don't declare greet() as static, it will be compile error

                                public static void main(String[] args) {
                                    A.greet(); //Output is: Hello.
                                    B.greet(); //Output is: Good afternoon.
                                }
                            }
                Variables cannot be overriden, only hidden
                    class Mammal{
                        public String name = "Unknown";
                        public void greet(){
                            System.out.println("Unknown greet method");
                        }
                    }
                    public class Dog extends Mammal{
                        public String name = "Rex";
                        public void greet(){
                            System.out.println("Rex greet method");
                        }

                        public static void main(String[] args) {
                            Dog d = new Dog();
                            Mammal m = d; // ~ Mammal m = new Dog();
                            System.out.println(d.name); //Output is: Rex
                            System.out.println(m.name); //Output is: Unknown
                            d.greet(); //Output is: Rex greet method
                            m.greet(); //Output is: Rex greet method  (why ? see keypoints below)
                            //Key points:
                                Variable Access: Determined by the reference type. `m.name` accesses name in Mammal
                                Method Call: Determined by the actual object type at runtime. `m.greet()` calls the greet method in Dog
                                             (because Mammal m = new Dog(), then m is pointing to object new Dog())
                        }
                    }
41. Abstract Classes:
        Classes which can be extended, but cannot be initialized
            Example:
                public abstract class Mammal {}  //Mammal is abstract class
                public class Dog extends Mammal {}  //Dog is concrete class
                Then
                Dog dog = new Dog(); //OK
                Mammal mdog = new Dog(): //OK
                Mammal mammal = new Mammal(); //DOES NOT COMPILE, because abstract class cannot be initialized
        Abstract methods, marked with abstract keyword, don't have a body, and the implementation (body) must be done in classes which extends an abstract class
        Rules for Using abstract methods
            Only instance methods can be marked abstract
                not variables, constructors, static methods, etc.
            Abstract method can only be declared in an abstract class
            Non-abstract class which extends abstract class MUST implement ALL inherited methods
            All other rules with overriding methods apply
        Example:
                abstract class Animal{
                    public abstract void speak();
                }
                abstract class Mammal extends Animal{
                    public abstract void walks(); //Mammal is also an abstract class, so it doesn't need to implement speak() method in abstract class Animal
                }
                public class Dog extends Mammal{ //Dog now must implement abstract method in both Animal and Mammal abstract classes
                    @Override
                    public void speak(){ System.out.println("Woof!"); }
                    @Override
                    public void walks(){ System.out.println("Dog walks"); }
                    public static void main(String[] args){
                        Dog dog = new Dog();
                        dog.speak();
                        dog.walks();
                    }
                }
        Keep in mind...
                abstract class can have constructors
                    but they can be called only using super() from the child class (because abstract cannot be initialized, so there's no other way to do that)
                abstract class or method cannot be marked final
                abstract method cannot be marked private
                static method cannot be overriden
                    therefore, abstract static is not allowed
42. Interfaces
        a class can only extend one class
        but can implement many interfaces (using keyword implements, separated by comma(,))
            Example:
                //Defining an interface
                interface Animal{
                    void eat(); //implicitly to be public
                    void sleep(); //implicitly to be public
                }
                //Implement interface
                class Dog implements Animal{
                    public void eat(){ //Annotation @Override is optional, but keyword public here is required, because all abstract methods in interface are implicitly public,
                                                                                                                and follow the rule when overriding method, the overriden method
                                                                                                                must be at least as accessible as the original method. So here
                                                                                                                the original method in interface is public, so when implementing
                                                                                                                method you must declare public here
                        System.out.println("Dot is eating");
                    }
                    public void sleep(){ //Annotation @Override is optional, but keyword public here is required, because all abstract methods in interface are implicitly public,
                                                                                                                 and follow the rule when overriding method, the overriden method
                                                                                                                 must be at least as accessible as the original method. So here
                                                                                                                 the original method in interface is public, so when implementing
                                                                                                                 method you must declare public here
                        System.out.println("Dog is sleeping");
                    }
                }
        Rules of implementation
                Keyword public is required
                Return type must be covariant with the interface method - Return type of overriden method must be the same or a subtype of the return type of the original method of interface
                Signature (name & parameters) must match the interface method
                All inherited methods must be implemented
        An interface can extends another interface
                Example:
                    public interface Mammal{
                        public int eats();
                    }
                    public interface canSwim extends Mammal{
                        public int swim();
                    }
                    public class Elephant implements canSwim{
                        public int swim() { return 5; }
                        public int eats() { return -1; }
                    }
        Default Interface Methods
                Image you have an interface which is implemented by 100 classes
                For some reason you need to add another method in your interface
                For this method were abstract, you would need to get back to the sourcecode, and implement it in all 100 classes
                This is solved by making a method default (non-abstract)
                Default method must have a body (default implementation)
        Rules for Using Default Methods
                Keyword default with a method can only be used in the interface
                Has to have a body (default implementation)
                Implicitly public
                Default method cannot be abstract, final or static
                Default method may or may not be overriden by a class implementing the interface
                If the class inherits two or more default methods with the same method signature, then it must override the method
                    Example:
                        public interface Car{
                            public default int getMaxSpeed(){
                                return 100;
                            }
                        }
                        public interface Truck{
                            default int getMaxSpeed(){
                                return 70;
                            }
                        }
                        public class Van implements Car, Truck{
                            public int getMaxSpeed(){ // We must override getMaxSpeed() because there are two of them with a same signature in interface Car and Truck also.
                                return 80;
                            }
                            public int getMaxSpeedCar(){
                                return Car.super.getMaxSpeed(); // This is how we call the default method from Car interface
                            }
                        }
        Static interface methods
            Example:
                public interface Car{
                    static int getMaxSpeed(){
                        return 100;
                    }
                }
                public class Ford implements Car{
                    public int getMaxSpeedCar(){
                        return Car.getMaxSpeed(); // This is how we call static method in interface Car
                    }
                }
        Private interface methods
            Example:
                public interface Car{
                    private static int calculateSpeed(){
                        int speed = 70 * 2;
                        return speed;
                    }
                    public default int getMaxSpeed(){
                        return calculateSpeed(); //write a private method and then call private method in same interface to make code more readable
                    }
                    public default int getRecommendedSpeed(){
                        return (int)(calculateSpeed() * 0.8); //write a private method and then call private method in same interface to make code more readable
                    }
                }
        Rules for Using Private Methods
                marked with keyword private
                must have a body
                private static methods may be called by any method in the same interface
                non-static private methods may be called only by non-static methods
        Default and private non-static methods can call abstract methods
43. Functional Interfaces and Lambdas
          Functional Interface:
                    Is an interface which has exactly one abstract method
                    Can be annotated with @FunctionalInterface
                    Java provides many pre-defined functional interfaces such as Supplier, Consumer, Predicate, Function, etc.
                          Example 1:
                              @FunctionalInterface   //This is optional annotation
                              interface Animal{
                                    public void speak();
                              }
                              class Dog implements Animal{
                                    public void speak() { System.out.println("Woof!"); }
                              }
                          Example 2: Specific case that we don't need to create concrete class to implement the interface
                               @FunctionalInterface
                               interface Animal{
                                    public void speak();
                               }
                               public class MyClass{
                                public static void main(String[] args){
                                  Animal dog = new Animal(){
                                    public void speak() { System.out.println("Woof!"); } //implement abstract method directly inside new object of class Animal
                                  }
                                }
                              }
          Lambda Expression:
                    Let's do the same thing as example 2 above in lambda expression syntax
                    Example:
                            @FunctionalInterface
                            interface Animal{
                                public void speak();
                            }
                            public class MyClass{
                                public static void main(String[] args){
                                        Animal dog = () -> System.out.println("Woof!"); //in this case there's no input argument, so write () here
                                                                                                                                //like arrow function in Javascript
                                                                                                                                //after -> , if there are more than one statement, need to put inside block code {}
                                                                                                                                //Remember, this statement is just to implement abstract metod
                                        dog.speak(); //use it to call the method speak() which is already implemented
                                }
                            }
                    ==> Lambda provides the implementation of abstract method in a functional interface
                        Remember Lambda syntax only used with the functional interface because functional interface only have one abstract method
                        Remember class include lambda syntax don't need keyword implements, if so there will be compile error
          Benefits of using lambda: You can see we don't need to create a class to implement interface
                                     and with lambda, it's very useful to provide different implementations in the same class
                Example:
                    @FunctionalInterface
                    interface Animal{
                        public void speak();
                    }
                    public static void main(String[] args){
                          Animal dogImplementation = () -> System.out.println("Woof!"); //implementation so it will not print out the System...
                          Animal catImplementation = () -> System.out.println("Meow!");
                          Animal cowImplementation = () -> System.out.println("Moo!");
                          dogImplementation.speak(); //Output is: Woof!
                          catImplementation.speak(); //Output is: Meow!
                          cowImplementation.speak(); //Output is: Moo!
                    }
          Using lambda in case abstract method have parameters and return type
                Example:
                      @FunctionalInterface
                      interface Multiplicable{
                            public int multiply(int a, int b);
                      }
                      public class MyClass{  //Don't write implements here, if so there will be compile error
                            public static void main(String[] args){
                            Multiplicable myImplementation = (a, b) -> a * b;
                            int result = myImplementation.multiply(3, 4);
                            System.out.println(result);
                          }
                      }
          Allowed variations in lambda syntax
                one parameter
                    n -> 2 * n
                    (n) -> 2 * n
                    (int n) -> 2 * n
                    n -> { return 2 * n; }
                    (n) -> { return 2 * n; }
                    (int n) -> { return 2 * n; }
                more parameters
                    (a, b) -> a * b
                    (int a, int b) -> a * b
                    (a, b) -> { return a * b; }
                    (int a, int b) -> { return a * b; }
          Using `Predicate` with lambda
                Predicate
                        Is a pre-defined functional interface provided by Java
                        In order to use it java.util.function package must be imported
                        Predicate has one abstract method that is test(T)
                                which takes an argument of type T and returns boolean
                        Predicate interface looks like
                                        @FunctionalInterface
                                        public interface Predicate<T>{
                                                boolean test(T t);  //have only one abstract method test
                                                // ...could have some other static and private methods here
                                        }
                        In order to use Predicate you have to implement test(T) method and then you can use it
                        Example 1:
                                import java.util.function.*;
                                public class MyClass{
                                        public static void main(String[] args){
                                            Predicate<Integer> gt10 = n -> n > 10;
                                            System.out.println(gt10.test(7)); //Output is: false
                                            System.out.println(gt10.test(12)); //Output is: true
                                      }
                                  }
                        Example 2: tricky example
                                import java.util.function.*;
                                public class MyClass{
                                    static void myProbe(int n, Predicate<Integer> predicate){
                                        if(predicate.test(n)){
                                            System.out.println("The test has been passed.");
                                        } else System.out.println("The test has been failed.");
                                    }
                                    public static void main(String[] args){
                                        myProbe(4, predicate -> predicate >= 5); //Output is: The test has been failed.
                                        myProbe(18, predicate -> predicate % 2 == 0); //Output is: The test has been passed.

                                        //can also like that
                                        Predicate<Integer> myCriteriom = n -> n * n + 5 > 100;
                                        myProbe(2, myCriteriom);
                                  }
                              }
          Method references:
              Is a shorter way of writing lambda expression
              Example: basic example
                    @FunctionalInterface
                    public interface Animal{
                        public void speak(String s);
                    }
                    public class MyClass{
                        public static void main(String[] args){
                                Normal way:  Animal myAnimal = s -> System.out.println(s); //normal way to write lambda expression
                                //But the above line can be shorter by using method references
                                Using method references way: Animal myAnimal = System.out::println;
                                myAnimal.speak("Woof!"); //Output is: Woof!
                        }
                    }
          Method references and context
                    Java already knows number of parameters of abstract method
                        so they are automatically inserted without the need of explicitly list them
                        for example: s -> System.out.println(s); ==> Java already know the abstract method speak() in Animal interface only have one parameter
                                                                                                             so we can write like this: s -> System.out::println;
          Using method reference with static method, e.g Math.min()
                Example 1:
                      @FunctionalInterface
                      interface Calculator{
                            public int minimum(int a, int b);
                      }
                      public class MyClass{
                            public static void main(String[] args){
                                Normal way: Calculator lambda = (a, b) -> Math.min(a, b);
                                //But the above line can be shorter by using method reference
                                Using method references way: Calculator methodRef = Math::min;
                                System.out.println(lambda.minimum(4, 2); //Output is: 2
                                System.out.println(methodRef.minimum(4, 2): //Output is also: 2
                            }
                      }
                Example 2:
                      @FunctionalInterface
                      interface Calculator{
                            public double path(double t);
                      }
                      class Gravity{
                            public static double freeFall(double t){
                                final double g = 9.81;
                                return 0.5 * g * t * t;
                            }
                      }
                      public class MyClass{
                            public static void main(String[] args){
                                Normal way: Calculator lambda = t -> Gravity.freeFall(t);
                                Using method references: Calculator methodRef = Gravity::freeFall;
                                System.out.println(lambda.path(10));
                                System.out.println(methodRef.path(10));
                            }
                      }
          Calling method reference on an Object
                @FunctionalInterface
                interface Checker{
                    public boolean check();
                }
                public class MyClass{
                    public static void main(String[] args){
                        String s = "Foden Duong";
                        Normal way: Checker lambda = () -> s.isEmpty();
                        Using method reference way: Checker methodRef = s::isEmpty;  //call method isEmpty() of object s
                        System.out.println(methodRef.check());
                    }
                }
          Calling method reference on a parameter
                @FunctionalInterface
                interface Checker{
                    public boolean check(String s);
                }
                public class MyClass{
                    public static void main(String[] args){
                        Normal way: Checker lambda = s -> s.isBlank();
                        Using method reference: Checker methodRef = String::isBlank; //method reference, must not write isBlank(), or isEmpty(),... must write isBlank, isEmpty,...
                        System.out.println(methodRef.check("     ")); //Output is: true
                    }
                }
          Calling constructor reference
                @FunctionalInterface
                interface Teller{
                    String tellName(String name);
                }
                public class MyClass{
                    public static void main(String[] args){
                        Normal way: Teller lambda = s -> new String(s);
                        Using method reference: Teller methodRef = String::new;
                        System.out.println(lambda.tellName("Foden Duong"));
                        System.out.println(methodRef.tellName("Foden Duong"));
                    }
                }
          Summary some case of using method references
                |           Lambda                  |           Method reference
                |   s ->  System.out.println(s);    |   System.out::println
                |   (a, b) -> Math.min(a, b)        |   Math::min
                |   t -> Gravity.freeFall(t)        |   Gravity::freeFall
                |   () -> s.isEmpty()               |   s::isEmpty
                |   s -> s.isBlank()                |   String::isBlank
                |   s -> new String(s)              |   String::new
          Built-in Functional Interfaces
                java.util.function package
                        This package contains many built-in functional interfaces
                        In order to use them, you have to know
                            Name of the interface
                            Signature of the abstract method
                            Return type of the abstract method
                        This leads to a paradigm usually referred to as functional programming
                Most common Functional Interfaces
                        |       Functional Interface    |       Method signature    |       Return type |
                        |   Supplier<T>                 |   get()                   |   T               |
                        |   Consumer<T>                 |   accept(T)               |   void            |
                        |   BiConsumer<T, U>            |   accept(T, U)            |   void            |
                        |   Predicate<T>                |   test(T)                 |   boolean         |
                        |   BiPredicate<T, U>           |   test(T, U)              |   boolean         |
                        |   Function<T, R>              |   apply(T)                |   R               |
                        |   BiFunction<T, U, R>         |   apply(T, U)             |   R               |
                        |   UnaryOperator<T>            |   apply(T)                |   T               |
                        |   BinaryOperator<T>           |   apply(T, T)             |   T               |
                Supplier
                    @FunctionalInterface
                    public interface Supplier<T>{
                        T get();
                    }
                    Example:
                            import java.util.function.*;
                            import java.time.*;
                            pulic class MyClass{
                                public static void main(String[] args){
                                    Supplier<LocalDateTime> dtImpl = () -> LocalDateTime.now();
                                    System.out.println(dtImpl.get());  //prints out the local date time
                                }
                            }
                Consumer, BiConsumer
                    @FunctionalInterface
                    public interface Consumer<T>{
                        void accept(T t);
                        //... This is how Consumer interface looks like, has only one abstract method accept(T t), and some of others non abstract
                    }
                    @FunctionalInterface
                    public interface BiConsumer<T, U>{
                        void accept(T t, U u);
                        //... This is how BiConsumer interface looks like, has only one abstract method accept(T t), and some of others non abstract
                    }
                    Example:
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                //Consumer
                                Consumer<String> greet = s ->   System.out.println("Hello, " + s + "!");
                                greet.accept("Foden Duong");

                                //BiConsumer
                                BiConsumer<String, Integer> p = (name, age) -> System.out.println(name + " is " + age + " years old.");
                                p.accept("Foden", 25);
                            }
                        }
                Predicate, BiPredicate
                    @FunctionalInterface
                    public interface Predicate<T>{
                        boolean test(T t);
                        //...
                    }
                    @FunctionalInterface
                    public interface BiPredicate<T, U>{
                        boolean test(T t, U u);
                        //...
                    }
                    Example:
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                //Predicate
                                Predicate<Integer> predicate = n -> n > 10;
                                System.out.println(predicate.test(7));

                                //BiPredicate
                                BiPredicate<Integer, Integer> biPredicate = (m, n) -> m > n;
                                System.out.println(biPredicate.test(11, 9));
                            }
                        }
                Function, BiFunction
                    @FunctionalInterface
                    public interface Function<T, R>{
                        R apply(T t);
                        //...
                    }
                    @FunctionalInterface
                    public interface BiFunction<T, U, R>{
                        R apply(T t, U u);
                    }
                    Example:
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                //Function
                                Function<Integer, Double> square = s -> (double) (n * n);
                                var res = square.apply(5);
                                System.out.println(res);

                                //BiFunction
                                BiFunction<String, Integer, String> con = (s, i) -> s + i;
                                System.out.println(con.apply("Foden's age is: ", 25);
                            }
                        }
                UnaryOperator, BinaryOperator
                    @FunctionalInterface
                    public interface UnaryOperator<T> extends Function<T, T>{
                        //...
                    }
                    @FunctionalInterface
                    public interface BinaryOperator<T> extends BiFunction<T, T, T>{
                        //...
                    }
                    Example:
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                //UnaryOperator example
                                UnaryOperator<Integer> negative = n -> -n;
                                System.out.println(negative.apply(4)); //Output is: -4

                                UnaryOperator<String> shout = String::toUpperCase; (~~ shout = s -> s.toUpperCase();)
                                System.out.println(shout.apply("Foden")); //Output is: FODEN

                                //BinaryOperator example
                                BinaryOperator<Double> add = (a, b) -> a + b;
                                System.out.println(add.apply(3.2, 4.0));

                                BinaryOperator<String> con = String::concat;
                                System.out.println(con.apply("Foden", " Duong")); //Output is: Foden Duong
                            }
                        }
          Combining Implementations:
                Helper Methods provided by FI's
                    Consumer
                            andThen()
                    Function
                            andThen()
                            compose()
                    Predicate
                            and()
                            or()
                            negate()
                Example 1: Consumer
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                Consumer<String> greet1 = s -> System.out.println("Hello, " + s + "!");
                                Consumer<String> greet2 = s -> System.out.println("Bye, " + s + "!");
                                //First way
                                Consumer<String> combinedGreet = greet1.andThen(greet2);
                                combinedGreet.accept("Foden");
                                //Second way
                                greet1.andThen(greet2).accept("Foden");
                            }
                        }
                Example 2: Function
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                Function<Integer, Integer> square = n -> n * n;
                                Function<Integer, Integer> triple = n -> 3 * n;
                                Function<Integer, Integer> f1 = square.andThen(triple);
                                Function<Integer, Integer> f2 = square.compose(triple);
                                System.out.println(f1.apply(5)); //Output is: 75 (5 x 5 = 25, then 3 * 25 = 75)
                                System.out.println(f2.apply(5)); //Output is: 225 ((3 * 5) * (3 * 5) = 225, that means for a given integer we are first tripling it and then we square the result)
                            }
                        }
                Example 3: Predicate
                        import java.util.function.*;
                        public class MyClass{
                            public static void main(String[] args){
                                Predicate<Integer> gt10 = n -> n > 10;
                                Predicate<Integer> lt20 = n -> n < 20;
                                Predicate<Integer> p1 = gt10.and(lt20);
                                Predicate<Integer> p2 = gt10.or(lt20);
                                Predicate<Integer> p3 = lt20.negate(); //negate here means negative, p3.test(5) will return false because 5 less than 20, so it's correct and so it does not negate
                                System.out.println(p1.test(5) + " " + p2.test(5) + " " + p3.test(5)); //Output is: false true false
                            }
          Functional Interfaces for Primitives
                |       Functional Interface        |       Return Type     |       Abstract Method Signature
                |   BooleanSupplier                 |   boolean             |   getAsBoolean()
                |   DoubleSupplier                  |   double              |   getAsDouble()
                |   IntSupplier                     |   int                 |   getAsInt()
                |   LongSupplier                    |   long                |   getAsLong()
                |   DoubleConsumer                  |   void                |   accept(double a)
                |   IntConsumer                     |   void                |   accept(int a)
                |   LongConsumer                    |   void                |   accept(long value)
                |   DoublePredicate                 |   boolean             |   test(double value)
                |   IntPredicate                    |   boolean             |   test(int value)
                |   LongPredicate                   |   boolean             |   test(long value)
                |   DoubleFunction<R>               |   R                   |   apply(double value)
                |   IntFunction<R>                  |   R                   |   apply(int value)
                |   LongFunction<R>                 |   R                   |   apply(long value)
                |   DoubleUnaryOperator             |   double              |   applyAsDouble(double value)
                |   IntUnaryOperator                |   int                 |   applyAsInt(int value)
                |   LongUnaryOperator               |   long                |   applyAsLong(long value)
                |   DoubleBinaryOperator            |   double              |   applyAsDouble(double v, double w)
                |   IntBinaryOperator               |   int                 |   applyAsInt(int v, int w)
                |   LongBinaryOperator              |   long                |   applyAsLong(long v, long w)
                |   ToDoubleFunction<T>             |   double              |   applyAsDouble(T t)
                |   ToIntFunction<T>                |   int                 |   applyAsInt(T t)
                |   ToLongFunction<T>               |   long                |   applyAsLong(T t)
                |   ToDoubleBiFunction<T, U>        |   double              |   applyAsDouble(T t, U u)
                |   ToIntBiFunction<T, U>           |   int                 |   applyAsInt(T t, U u)
                |   ToLongBiFunction<T, U>          |   long                |   applyAsLong(T t, U u)
                |   DoubleToIntFunction             |   int                 |   applyAsInt(double value)
                |   DoubleToLongFunction            |   long                |   applyAsLong(double value)
                |   IntToDoubleFunction             |   double              |   applyAsDouble(int value)
                |   IntToLongFunction               |   long                |   applyAsLong(int value)
                |   LongToDoubleFunction            |   double              |   applyAsDouble(long value)
                |   LongToIntFunction               |   int                 |   applyAsInt(long value)
                |   ObjDoubleConsumer<T>            |   void                |   accept(T t, double value)
                |   ObjIntConsumer<T>               |   void                |   accept(T t, int value)
                |   ObjLongConsumer<T>              |   void                |   accept(T t, long value)
44. Collections
        Common Collection Methods
                These interfaces are commonly referred to as collections
                        List, Set, Queue(Deque), Map
                Classes which implement these above interfaces
                        Interfaces `List`, `Set`, and `Queue` extend interface `Collection`
                        Class `ArrayList` implements interface `List`
                        Classes `HashSet`, and `TreeSet` implement interface `Set`
                        Interface `Deque` implements interface `Queue`
                        Class `LinkedList` implements interfaces `Queue`, and `List`
                        Interface `Map` doesn't implement interface `Collection` (but nevertheless we refer to Maps as collections because they behave very similarly to classes
                                                                                  and interfaces which actually implement the interface `Collection`)
                        Classes `HashMap`, and `TreeMap` implement `Map` interface

                                                                                +-----------------------+
                                                                                |      Collection       |
                                                                                |      (Interface)      |
                                                                                +-----------+-----------+
                                                                                            |
                                                                        +-------------------+------------------+
                                                                        | extends           | extends          | extends
                                                            +---------------+        +---------------+   +-------------------+
                                                            |(Interface)List|        |(Interface)Set |   | (Interface) Queue |
                                                            +---------------+        +---------------+   +-------------------+
                                                                        | implements        | implements       | extends
                                                                 +-----------------+  +---------------+   +-------------------+
                                                                 |(Class)ArrayList |  |(Class) HashSet|   | Deque (Interface) |
                                                                 |(Class)LinkedList|  |(Class) TreeSet|   +-------------------+
                                                                 +-----------------+  +---------------+        |
                                                                                                               | implements
                                                                                                     +-------------------+
                                                                                                     |(Class) LinkedList |
                                                                                                     +-------------------+
                                                        ==========================================================================
                                                                                +--------------------+
                                                                                |    Map(Interface)  |
                                                                                +--------------------+
                                                                            implements/              \implements
                                                                       +-----------------+      +-----------------+
                                                                       | HashMap (Class) |      | TreeMap (Class) |
                                                                       +-----------------+      +-----------------+
                add() method: adds an element in the collection, returns true or false
                        Example:
                            Collection<String> names = new ArrayList<>();
                            System.out.println(names.add("John")); //Output is: true
                            System.out.println(names.add("John")); //Output is: true
                            but
                            Collection<String>names = new HashSet<>();
                            System.out.println(names.add("Foden")); //Output is: true
                            System.out.println(names.add("Foden")); //Output is: false (Because Set doesn't allow duplicates)
                remove() method: removes an element in the collection, returns true or false
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Duong");
                            names.add("Foden");
                            System.out.println(names); //Output is: [Foden, Duong, Foden]
                            System.out.println(names.remove("Foden")); //Output is: true
                            System.out.println(names); //Output is: [Duong, Foden] (only the first match is removed by the above line)
                            System.out.println(names.remove("Lukaku")); //Output is: false (since there's no element Lukaku in the collection)
                isEmpty() method:
                        Example:
                            Collection<String> names = new ArrayList<>();
                            System.out.println(names.isEmpty()); //Output is: true
                size() method:
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Duong");
                            names.add("Foden");
                            System.out.println(names.size()); //Output is: 3
                clear() method: Removes all elements from the collection
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Duong");
                            names.add("Foden");
                            name.clear();
                            System.out.println(names.size()); //Output is: 0
                contains() method: Check if the collection contains an element or not and returns true or false
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Duong");
                            names.add("Foden");
                            System.out.println(names.contains("Duong")); //Output is: true
                            System.out.println(names.contains("Vinh")); //Output is: false
                removeIf() method: Removes elements with condition
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Vinh");
                            names.removeIf(s -> s.length() > 4);
                            System.out.println(names); //Output is: [Vinh]
                forEach() method:
                        Example:
                            Collection<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Duong");
                            names.add("Vinh");
                            names.forEach(name -> System.out.print(name + ", ")); //Output is: Foden, Duong, Vinh
        List interface:
                List is an ordered collection which can contain duplicate entries
                Items can be reached and inserted using the index (int)
                Unlike array, List  can change in size after being declared
                There are two classes which implement List interface: ArrayList and LinkedList
                    ArrayList  is better when you read more than you write
                    LinkedList implements both List and Deque interface
                Creating a List using factory methods:
                        Arrays.asList(varargs)
                                fixed size list, can modify value of elements, but cannot add or remove element because the size is fixed
                                is backed by the array, means any changes in the array will be reflected to the list
                                Example:
                                        String[] names = new String[] {"Foden", "Duong", "Vinh"};
                                        List<String> list = Arrays.asList(names);
                                        names[1] = "Micheal";
                                        System.out.println(list); //Output is: [Foden, Micheal, Vinh] (changes in array names, will be reflected to the array list)
                                        list.set(2, "Phil"); //OK
                                        System.out.println(list); //Output is: [Foden, Micheal, Phil]
                                        Also
                                        System.out.pritln(Arrays.toString(names)); //Output is: [Foden, Micheal, Phil] (so can see the changes in list will be also reflected back to array
                                                                                                                        so we can say Backing up works both ways)
                                        list.add("Micheal"); //throws UnsupportedOperationException
                                        list.remove("Foden"); //throws UnsupportedOperationException
                        List.of(varargs)
                                returns immutable list, cannot change value of elements also cannot add or remove element
                                Example:
                                        String[] names = new String[] {"Foden", "Duong", "Vinh"};
                                        List<String> list = List.of(names);
                                        names[1] = "Micheal";
                                        System.out.println(list); //Output is: [Foden, Duong, Vinh] (changes in array names, will NOT be reflected to array)
                                        list.set(1, "Phil"); //throws UnsupportedOperationException
                                        list.add("Micheal"); //throws UnsupportedOperationException
                                        list.remove("Foden"); //throws UnsupportedOperationException
                        List.copyOf(collection)
                                immutable list with copy of original values
                                Example:
                                        List<String> originalList = new ArrayList<>(Arrays.asList("Foden", "Duong", "Vinh"));
                                        List<String> copyList = List.copyOf(originalList);
                                        copyList.set(1, "Phil"); //throws UnsupportedOperationException
                                        copyList.add("Micheal"); //throws UnsupportedOperationException
                                        copyList.remove("Foden"); //throws UnsupportedOperationException
                                        but
                                        originalList.set(1, "Phil"); //OK
                                        originalList.add("Micheal"); //OK
                                        originalList.remove("Foden"); //Also OK, because originalList is declared as List<String> originalList = new ArrayList<>(...);
                        ==> List created by a factory method has a fixed size!
                Creating a List with a constructor:
                        Example:
                                List<String> myList = new ArrayList<>();
                            Also
                                ArrayList<String> myArrList = new ArrayList<>();
                            Also
                                ArrayList<String> myArrList = new ArrayList<>(5); //Add 5 here to tell the compiler that we want to reserve 5 slots,
                                                                                  //for size of arrList, but you can add more later, the size will automatically increase
                List Methods:
                        add(E element)
                        add(int index, E element)
                        get(int index)
                        remove(int index)
                        remove(E element)
                        replaceAll(UnaryOperator<E> op)
                        set(int index, E element) //update value of element
                        sort(Comparator<? super E> c)
                    Example:
                            List<String> names = new ArrayList<>();
                            names.add("Foden");
                            names.add("Vinh");
                            names.add("Phil");
                            System.out.println(names); //Output is: [Foden, Vinh, Phil]
                            names.add(1, "Duong");
                            System.out.println(names); //Output is: [Foden, Duong, Vinh, Phil]
                            System.out.println(names.get(0)); //Output is: Foden
                            names.set(2, "Micheal");
                            System.out.println(names); //Output is: [Foden, Duong, Micheal, Phil]
                            names.remove(2);
                            names.remove("Foden");
                            System.out.println(names); //Output is: [Duong, Phil]
                            names.replaceAll(s -> "Mr. " + s);
                            ystem.out.println(names); //Output is: [Mr. Duong, Mr. Phil]
                    two ways of using remove() method
                            Example:
                                    List<Integer> nums = new ArrayList<>();
                                    nums.add(2);
                                    nums.add(-21);
                                    nums.add(7);
                                    nums.remove(2); //Will remove element at index 2, which is 7
                                    nums.remove(Integer.valueOf(2)); //Will remove element has value 2, which is element at index 0
                                    ==> If we pass the argument type primitive, remove(int index) will be called
                                        If we pass the argument type Object , not primitive, remove(E element) will be called
                Converting List to Array using toArray() method
                            Example:
                                    List<Integer> myList = new ArrayList<>();
                                    myList.add(3);
                                    myList.add(7);
                                    myList.add(5);
                                    Object[] objArray = myList.toArray();
                                Or
                                    Integer[] intArray = myList.toArray(new Integer[0]); //Define 0 as default size of array, if list has more than 0 element,
                                                                                         //then array size will follow size of list
        Set interface:
                Doesn't allow duplicate entries
                Doesn't allow to find element by index (that means we don't have get() method for Set interface)
                Implementation: HashSet, TreeSet
                HashSet: stores(key, value) elements in hash table
                        key is hashCode(), value is Object
                        doesn't keep the order of elements
                        adding each element takes the same time
                TreeSet: stores elements in a sorted tree structure, it doesn't use (key, value) pair, it uses a tree structure
                        keep the order of elements
                        adding each element takes more time as tree goes bigger
                Example: HashSet
                        Set<String> names = new HashSet<>();
                        System.out.println(names.add("Foden")); //Output is: true
                        System.out.println(names.add("Duong")); //Output is: true
                        System.out.println(names.add("Foden")); //Output is: false (because we are adding duplicated entry)
                        System.out.println(names.add("Vinh")); //Output is: true
                        System.out.println(names); //Output is: [Duong, Foden, Vinh] (arbitrary order - Unpredictable, the order of elements may be changed in each runtime)
                Example: TreeSet
                        Set<String> names = new TreeSet<>();
                        System.out.println(names.add("Foden")); //Output is: true
                        System.out.println(names.add("Duong")); //Output is: true
                        System.out.println(names.add("Foden")); //Output is: false
                        System.out.println(names.add("Vinh")); //Output is: true
                        System.out.println(names); //Output is: [Duong, Foden, Vinh] (keeps order in String alphabetical order)
        Queue interface:
                Implemented by LinkedList Class
                Adds element in the back, reads from the front (every element is added at the back of the queue, but reading is done from the front of the queue)
                        This principle is called: FIFO - First In First Out
                Some proper methods:
                        peek(): is used to read the element from the front
                        offer(E e): puts element on the back
                        poll(): removes element from the front
                Some methods inherited from Collection:
                        element()
                        add(E e)
                        remove()
                ==> We can use either peek() or element, offer(E e) or add(E e), poll() or remove() to do the same thing
                    Only thing difference here is:
                            In the case of unsuccessful operation, peak() and poll() return null on empty queues, offer(E e) returns false if it fails to add due to capacity restrictions
                            while the Collection methods throw the exception
                Example 1: LinkedList with reference type is Queue
                        Queue<String> colors = new LinkedList<>();
                        colors.offer("blue");
                        colors.offer("green");
                        colors.offer("red");
                        colors.offer("yellow");
                        System.out.println(colors); //Output is: [blue, green, red, yellow]
                        System.out.println(colors.peek()); //Output is: blue (get first element)
                        colors.poll(); //remove first element
                        System.out.println(colors); //Output is: [green, red, yellow]
                        System.out.println(colors.peek()); //Output is: green (get first element)
                Example 2: LinkedList with reference type is Deque
                        Deque<String> list = new LinkedList<>();
                        list.add("Foden");
                        list.add("Duong");
                        list.add("Vinh");
                        list.addFirst("Micheal");
                        list.addLast("Phil");
                        System.out.println(list.getFirst());
                        System.out.println(list.getLast());
                        list.removeFirst();
                        list.removeLast();
                        list.remove("Foden");
                Example 3: LinkedList with reference type is List interface - NOT support addFirst(), addLast(), getFirst(), getLast(), removeFirst(), and removeLast()
        Deque interface:
                Implemented by LinkedList and ArrayQueue
                Adds element in the front, but reads from the back - Works as a Stack
                        This principle is called: LIFO - Last In First Out
                Example 1: ArrayDeque with reference type Deque
                        Deque<String> colors = new ArrayDeque<>();
                        colors.push("blue");
                        colors.push("green");
                        colors.push("red");
                        colors.push("yellow");
                        System.out.println(colors); //Output is: [yellow, red, green, blue] (LIFO so yellow is last added, then showed first)
                        System.out.println(colors.peek()); //Output is: yellow
                        colors.pop(); //Remove first element, which is the last one was added
                        System.out.println(colors.peek()); //Output is: red
                        colors.pop();
                        colors.pop();
                        colors.pop();
                        System.out.println(colors.peek()); //Output is: null
                Example 2: LinkedList with reference type Deque
                        Deque<Integer> nums = new LinkedList<>();
                        nums.addFirst(9);
                        nums.offerFirst(-11);
                        nums.addLast(5);
                        System.out.println(nums); //Output is: [-11, 9, 5]
                        System.out.println(nums.getFirst()); //Output is: -11
                        System.out.println(nums.peekLast()); //Output is: 5
                        nums.pollFirst();
                        System.out.println(nums); //Output is [9, 5]
                        System.out.println(nums.getFirst()); //Output is: 9
                        System.out.println(nums.peekLast()); //Output is: 5
        Deque Interface as Double-Ended Queue
                    Here is a complete list of Deque methods for reference:
                            Queue-like Methods:
                                    add(E e)
                                    offer(E e)
                                    remove()
                                    poll()
                                    element()
                                    peek()
                            Deque-specific Methods:
                                    addFirst(E e)
                                    addLast(E e)
                                    offerFirst(E e)
                                    offerLast(E e)
                                    removeFirst()
                                    removeLast()
                                    pollFirst()
                                    pollLast()
                                    getFirst()
                                    getLast()
                                    peekFirst()
                                    peekLast()
        Map Interface
                Collection which stores (key, value) pairs
                Two implementations of Map interface:
                        HashMap:
                                order doesn't matter
                                same amount of time to add and get element
                        TreeMap:
                                order is preserved
                                takes more time to add elements as map goes bigger
                Example:
                        Map<Integer, String> names = Map.of(1, "Foden", 2, "Duong", 3, "Vinh");
                        System.out.println(names); //Output is: {1=Foden, 2=Duong, 3=Vinh}

                        //Another way
                        Map<Integer, String> names = new HashMap<>(); //create an empty map
                        names = Map.ofEntries(
                            Map.entry(1, "Foden"),
                            Map.entry(2, "Duong",
                            Map.entry(3, "Vinh"));
                        System.out.println(names); //Output is: {3=Vinh, 1=Foden, 2=Duong} (in HashMap the order is not preserved, so basically
                                                                                            you don't know in which order this will be printed out)
                Map Methods:
                        clear(): clears the map
                        containsKey(Object key): checks if the key is in the map
                        containsValue(Object value): checks if the value is in the map
                        entrySet(): returns Set of key/value pairs
                        forEach(): loops through key/value pairs
                        get(Object key): returns value mapped with key, or null if none exists
                        getOrDefault(Object key, V defaultValue): same as get, but returns defaultValue if key doesn't exist
                        isEmpty(): checks if map is empty
                        keySet(): returns Set of all keys
                        merge(K key, V value, BiFunction(<V, V, V> func): sets value if key doesn't exists, runs func if key is set to determine new value
                                                                          removes if value is null
                        put(K key, V value): adds or replaces k/v pair, returns previous value or null
                        putIfAbsent(K key, V value): if key not present, adds value and returns null (otherwise, returns the existing value)
                        remove(Object key): removes and returns value mapped to key, or null if none exists
                        replace(K key, V value): replaces value for given key if key is set, returns original value or null if none exists
                        replaceAll(BiFunction<K, V, V> func): replaces each value with results of function
                        size(): returns number of k/v pairs in the map
                        values(): returns Collection of values
                    Example:
                        Map<Integer, String> names = new HashMap<>();
                        names.put(5, "Foden");
                        names.put(11, "Duong");
                        names.put(-2, "Vinh");
                        String myName = names.get(-2);
                        System.out.println(myName); //Output is: Vinh

                        //loop over all keys
                        for (Integer key : names.keySet()){
                            System.out.println("Key: " + key + ", Value: " + names.get(key));
                        }

                        //using forEach()
                        names.forEach((k, v) -> System.out.println("Key: " + key + ", Value: " + names.get(key));

                        //just values
                        names.values().forEach(System.out::println);

                        //using entrySet()
                        names.entrySet().forEach(e -> System.out.println("Key: " + e.getKey() + ", Value: " + e.getValue()));

                        //using getOrDefault()
                        System.out.println(names.getOrDefault(-3, "Name not found"));

                        //using replace()
                        String myName = names.replace(-2, "Phil"); //replaces value on key = -2 with Phil, but also returns the old value = Vinh
                        System.out.println(myName); //So that output is Vinh

                        //putIfAbsent()
                        names.putIfAbsent(7, "Micheal");
                        names.putIfAbsent(-2, "John"); //will not execute put, because the key -2 already exists

                        //merge()
                        Map<Integer, String> names = new HashMap<>();
                        names.put(5, "Foden");
                        names.put(11, "Duong");
                        names.put(-2, "Vinh");
                            => want to insert name only if it is longer than the original name
                        BiFunction<String, String, String> myLogic = (name1, name2) -> name1.length() > name2.length() ? name1 : name2;
                        System.out.println(names.merge(5, "FodenD", myLogic));
                Sorting data in a collection
                        We are already partly familiar with sort() method
                        If elements in the collection are primitives, they are sorted by natural order
                        If elements are Strings, then numbers sort before letters, and uppercase letters sort before lowercase letters
                        But elements in the collection can be any type of object, in that case we have to define our own criteria of sorting
                        In order to do this we can choose one of two approaches
                                Use a class which implements Comparable<T> interface, or
                                Pass the implementation of Comparator<T> interface in sort() method
                        Comparable<T> interface
                                This interface has one abstract method: int compareTo(T o), this methods has to be implemented in a concrete class.
                                        this method returns an integer according to these rules:
                                                If the current object is equivalent to the argument it returns 0
                                                If the current object is smaller than the argument it returns a negative number
                                                If the current object is larger than the argument it returns a positive number
                                Example 1: define Person objects will be sorted by age
                                        public class Person implements Comparable<Person>{
                                            private String name;
                                            private int age;
                                            public Person(String name, int age){
                                                this.name = name;
                                                this.age = age;
                                            }
                                            @Override
                                            public int compareTo(Person other){
                                                return this.age - other.age;
                                            }
                                            //toString() implementation
                                        }
                                        public class Main{
                                            public static void main(String[] args){
                                                List<Person> people = Arrays.asList(
                                                    new Person("Foden", 25),
                                                    new Person("Duong", 30),
                                                    new Person("Vinh", 35)
                                                );
                                                Collections.sort(people);
                                                System.out.println(people);
                                                //Output is like below:
                                                  [
                                                    Person{name='Foden', age=25},
                                                    Person{name='Duong', age=30},
                                                    Person{name='Vinh', age=35}
                                                  ]
                                                ===> because List<Person> is a list of objects, if we do not implement Comparable, and override compareTo(Person other) method
                                                     to define how Person objects should be compared, when using Collections.sort(people), you will get error
                                                            Exception in thread "main" java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable
                                                            at java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)
                                                            at java.util.ComparableTimSort.sort(ComparableTimSort.java:188)
                                                            at java.util.Arrays.sort(Arrays.java:1312)
                                                            at java.util.Collections.sort(Collections.java:223)
                                                            at Main.main(Main.java:10)
                                            }
                                        }
                                Example 2: define Person objects will be sorted by name
                                        public class Person implements Comparable<Person>{
                                            private String name;
                                            private int age;
                                            public Person(String name, int age){
                                                this.name = name;
                                                this.age = age;
                                            }
                                            @Override
                                            public int compareTo(Person other){
                                                return this.name.compareTo(other.name);
                                            }
                                        }
                                        public class Main{
                                            public static void main(String[] args){
                                                List<Person> people = Arrays.asList(
                                                    new Person("Foden", 25),
                                                    new Person("Duong", 30),
                                                    new Person("Vinh", 35)
                                                );
                                                Collections.sort(people);
                                                System.out.println(people);
                                                //Output is like below:
                                                  [
                                                    Person{name='Duong', age=30},
                                                    Person{name='Foden', age=25},
                                                    Person{name='Vinh', age=35}
                                                  ]
                                                ===> because List<Person> is a list of objects, if we do not implement Comparable, and override compareTo(Person other) method
                                                     to define how Person objects should be compared, when using Collections.sort(people), you will get error
                                                            Exception in thread "main" java.lang.ClassCastException: Person cannot be cast to java.lang.Comparable
                                                            at java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)
                                                            at java.util.ComparableTimSort.sort(ComparableTimSort.java:188)
                                                            at java.util.Arrays.sort(Arrays.java:1312)
                                                            at java.util.Collections.sort(Collections.java:223)
                                                            at Main.main(Main.java:10)
                                            }
                                        }
                        Comparator<T> interface
                                Compared to 2 examples above, we need to define a criterium for sorting when designing a class Person (either by name or age)
                                What if we want to sort by name in one case, and by age in another ? That's when you may think about Comparator<T> interface
                                        and provide the implementation for compare(T o1, T o2) method
                                        this implementation is than passed to sort() method, to do this we usually use lambda expression or method reference
                                Example:
                                        public class Person{
                                            private String name;
                                            private int age;
                                            public Person(String name, int age){
                                                this.name = name;
                                                this.age = age;
                                            }
                                            public String getName() {return name};
                                            public int getAge() {return age};
                                        }
                                        public class Main{
                                            public static void main(String[] args){
                                                List<Person> people = Arrays.asList(
                                                    new Person("Foden", 30),
                                                    new Person("Phil", 25),
                                                    new Person("Vinh", 35)
                                                );
                                                //To sort by age using Comparator<T> interface
                                                    Collections.sort(people, (p1, p2) -> p1.getAge() - p2.getAge());
                                                or another way to write the same code above
                                                    Comparator<Person> byAge = (Person p1, Person p2) -> p1.getAge() - p2.getAge();
                                                    Collections.sort(people, byAge);
                                                //To sort by name using Comparator<T> interface
                                                    Collections.sort(people, (p1, p2) -> p1.getName().compareTo(p2.getName()));
                                                //To sort by name using comparing() method with method reference
                                                    Comparator<Person> c = Comparator.comparing(Person::getName);
                                                //To sort by name using comparing() method with method reference but in reversed order
                                                    Comparator<Person> c = Comparator.comparing(Person::getName).reversed;
                                                //To sort by name and then by age (if names are the same)
                                                    Comparator<Person> c = Comparator.comparing(Person::getName).thenComparingInt(Person::getAge);
                                            }
                                        }
                        Comparable vs Comparator in summary
                                |                                 |   Comparable                      |   Comparator                  |
                                |  package name (for import)      |   java.lang                       |   java.util                   |
                                |  must be implemented by a class |   Yes                             |   No                          |
                                |  method name in interface       |   compareTo()                     |   compare()                   |
                                |  number of method parameters    |   1                               |   2                           |
                                |  usually used with lambda       |   No                              |   Yes                         |
45. Exceptions
        Exceptions occurs when something goes wrong during the runtime, e.g
                You are trying to divide by zero
                You are trying to fetch the index of the array which does not exist
                You are trying to use null as a reference
                You are passing a value to a method which is not internally allowed
                You are trying to reach the file which does not exist
                You are trying to connect to a database which is not accessible
        Checked Exception
                Must be declared or handled by the application code where it is thrown
                All checked exceptions inherit Exception, but not RuntimeException
                Checked exception is declared when defining a method
                    using keyword throws
                Checked exception is handled using try-catch block
        Example:
                void readFirstByteFromFile(File fileName){
                    FileInputStream file = new FileInputStream(fileName);
                    byte x = (byte) file.read();
                    System.out.println(x);
                }
                //The code above will not be compiled because there are 2 possible issues,
                first is file not found, the second is the file maybe empty, so if it's empty
                and you try to read it, that's why java will not compile the block code above
                //First is to declare exception
                void readFirstByteFromFile(File fileName) throws IOException{ //this compiles, but still we didn't handle the exception
                    FileInputStream file = new FileInputStream(fileName);
                    byte x = (byte) file.read();
                    System.out.println(x);
                }
                //Second solution is to handle exceptions using try-catch block
                void readFirstByteFromFile(File fileName){
                    try {
                        FileInputStream file = new FileInputStream(fileName);
                        byte x = (byte) file.read();
                        System.out.println(x);
                    } catch (IOException e){
                        e.printStackTrace();
                    }
                    //this now compiles, and also to best practices
                }
        Main method must also declare or handle the CHECKED exception
                Example 4:
                        class OutOfMilkException extends Exception{
                            //custom checked exception
                        }
                        public class MyClass{
                            private static void getMilk() throws OutOfMilkException{
                                System.out.println("Getting the milk...");
                            }
                            public static void main(String[] args){
                                getMilk(); //DOES NOT COMPILE, because the main call getMilk() that declares the Checked Exception
                                                               then it must declare or handle exception
                            }
                            //To fix
                            public static void main(String[] args) throws OutOfMilkException{
                                getMilk(); //OK
                            }
                        }
        Unchecked exceptions:
                May or may not be handled
                Example 1: unchecked exception - do not handle
                        public class MyClass{
                            private static void printFourthElement(int[ a){
                                System.out.println(a[3]);
                            }
                            public static void main(String[] args){
                                int[] a = { -7, 11, 3};
                                printFourthElement(a); //Will get exception Array index out of bound here when running
                            }
                        }
                Example 2: unchecked exception - but with exception handled
                        public class MyClass{
                            private static void printFourthElement(int[ a){
                                try {
                                    System.out.println(a[3]);
                                } catch (ArrayIndexOutOfBoundsException e){
                                    System.out.println("There is no fourth element in the array. Sorry !!");
                                }
                            }
                            public static void main(String args[]){
                                int[] a = {-7, 11, 3};
                                printFourthElement(a); //Output is: There is no fourth element in the array. Sorry !!  (without any exception threw)
                            }
                        }
                You can also manually throw an exception
                        Example 3:
                                public class Student{
                                    private int id;
                                    private String fullName;
                                    public Student(int id, String fullName){
                                        if(id < 10 || fullName.length() > 100)
                                            throw new IllegalArgumentException();
                                        this.id = id;
                                        this.fullName = fullName;
                                    }
                                    public static void main(String[] args){
                                        Student student = new Student(1, "Foden Duong"); //the IllegalArgumentException will be threw here, because id < 10
                                    }
                                }
                Unchecked Exceptions summary
                        |   ArithmeticException             |   Thrown when code tries to divide with zero                                                                                                          |
                        |   ArrayIndexOutOfBoundsException  |   Thrown when code uses illegal index to access array element                                                                                         |
                        |   ClassCastException              |   Thrown when code tries to cast object to a class of which it is not an instance                                                                     |
                        |   NullPointerException            |   Thrown when there is a null reference where object is required                                                                                      |
                        |   IllegalArgumentException        |   Thrown by a programmer to indicate that the illegal or inappropriate argument has been passed to a method                                           |
                        |   NumberFormatException           |   Subclass of IllegalArgumentException, thrown then the code tries to convert String to a numeric type, but String doesn't have an appropriate format |
                Catching multiple exceptions
                        Example 1: One exception is a subclass of another
                                void readFirstByteFromFile(File fileName){
                                    try {
                                        FileInputStream file = new FileInputStream(fileName);
                                        byte x = (byte) file.read();
                                        System.out.println(x);
                                    } catch (FileNotFoundException e) {  //subclass
                                        e.printStackTrace();
                                    } catch (IOException e) {  //superclass
                                        e.printStackTrace();
                                    }
                                    ==> if we change the order above, catch super class first , then catch subclass, the code will not compile
                                }
                        Example 2A: One exception is independent of another
                                void readFirstByteFromFile(File fileName){
                                    try {
                                        FileInputStream file = new FileInputStream(fileName);
                                        byte x = (byte) file.read();
                                        System.out.println(x);
                                    } catch (IOException e) {
                                        e.printStackTrace();
                                    } catch (NumberFormatException e) {
                                        e.printStackTrace();
                                    }
                                    ==> if we change the order above, it's OK because they are independent
                                }
                        Example 2B: One exception is independent of another
                                void readFirstByteFromFile(File fileName){
                                    try {
                                        FileInputStream file = new FileInputStream(fileName);
                                        byte x = (byte) file.read();
                                        System.out.println(x);
                                    } catch (IOException | NumberFormatException e) {  //this syntax only works for independent classes
                                        e.printStackTrace();
                                    }
                                    ==> syntax here: catch (nameOfException1 | nameOfException2 referenceVariable)
                                }
                finally block
                        Example:
                                void readFirstByteFromFile(File fileName){
                                    try {
                                        FileInputStream file = new FileInputStream(fileName);
                                        byte x = (byte) file.read();
                                        System.out.println(x);
                                    } catch (IOException | NumberFormatException e) {
                                        e.printStackTrace();
                                    } finally {   //executed whether exception is caught or not
                                        System.out.println("Running readFirstByteFromFile...");
                                    }
                                }
                try-with-resources
                        Resource management:
                                Any external data sources (files, databases, etc...) are referred to as resources
                                Dealing with resource almost always requires three steps:
                                        1. Opening the resource
                                        2. Dealing with the resource(e.g read/write)
                                        3. Closing the resource
                                Forgetting to close the resource can cause many bad things
                                        1. Resource leak results in resource becoming inaccessible
                                        2. e.g inability to connect to database by your or other programs, etc...
                        Example 1:
                                //do not use try-with-resources
                                //method that opens a file, reads the data and closes the file
                                public void readFile(String file){
                                    FileInputStream is = null;
                                    try {
                                        is = new FileInputStream("myFile.txt");
                                        //read file data
                                    } catch (IOException e) {
                                        e.printStackTrace();
                                    } finally {
                                        if (is != null){
                                            try {
                                                is.close();
                                            } catch (IOException e2){
                                                e2.printStackTrace();
                                            }
                                        }
                                    }
                                }
                        Example 2:
                                //use try-with-resources
                                //also known as automatic resource management
                                public void readFile(String file){
                                    try(FileInputStream is = new FileInputStream("myFile.txt")){ //opening the resource and close it automatically
                                        //read file data
                                    } catch (IOException e){
                                        e.printStackTrace();
                                    }
                                }
                        Example 3:
                                //creating custom resource
                                public class MyFileClass implements AutoClosable{
                                    private final int num;
                                    public MyFileClass(int num){
                                        this.num = num;
                                    }
                                    @Override
                                    public void close(){
                                        System.out.println("Closing MyFileClass #" + num); //implementation of method close()
                                    }
                                }
                                //now using MyFileClass resource with explicit finally block
                                try(MyFileClass bookReader = new MyFileClass(1);
                                    MyFileClass movieReader = new MyFileClass(2)){
                                        System.out.println("try block");
                                        throw new RuntimeException(); //because exceptions here, so program will call the close() method to close resource
                                    } catch (Exception e){
                                        System.out.println("Catch block");
                                    } finally {
                                        System.out.println("finally block");
                                    }
                                ==> Output is:
                                    try block
                                    closing MyFileClass #2  (program will close all the resources, start with the latest that is MyFileClass(2))
                                    closing MyFileClass #1
                                    Catch block
                                    finally block
                Suppressed Exceptions
                        Suppose close() can throw an exception, e.g
                            public void close() throws IllegalStateExpression{
                                throw new IllegalStateException("The door does not close");
                            }
                        if try-with-resources block also throws an exception in catch block then
                            only the first exception iwill be caught
                            other exceptions will be suppressed
                        Example:
                                public class Door implements AutoClosable{
                                    public void close() throws IllegalStateExpression{
                                        throw new IllegalStateException("The door does not close"); //2nd exception, so it will be suppressed
                                    }
                                    public static void main(String[] args){
                                        try(Door d = new Door()){
                                            throw new IllegalStateException("Something is wrong"); //1st exception, so it will be caught
                                        } catch (IllegalStateExpression e){
                                            System.out.println("caught: " + e.getMessage());
                                            for(Throwable t : e.getSuppressed()){                    //Use this for loop to print out all the suppressed exceptions
                                                System.out.println("suppressed: " + t.getMessage());
                                            }
                                        }
                                    }
                                }
                                //Output is:
                                    caught: Something is wrong
                                    suppressed: The door does not close
46. Math APIs
        min() and max()
                Example:
                        int a = Math.max(3, 11); //a = 11
                        int b = Math.min(2, -4); //b = -4
                You can compare all types of numbers, but be aware of autocasting
                        Example:
                                long a = 5;
                                int b = 3;
                                int c = Math.max(a, b); //DOES NOT COMPILE, because when we have a is long, and b is int, then the autocasting will be performed on b
                                                                            so both numbers will be long now, then c must b long, but we declare c as int, that's why compile error comes here
                                to fix, define c as long, or declare casting like below
                                int c = (int) Math.max(a, b); //c = 5
        round()
                Takes decimal number and returns integral number
                        if parameter is float, return type will be int
                        if parameter is double, return type will be long
                Example:
                        double d = 2.56;
                        long a = Math.round(d); //a = 3
                        int b = Math.round(d); //DOES NOT COMPILE, because d type double, so Math.round(d) will return a long number not int
        ceil() and floor()
                Take any number and always returns double
                Example:
                        double r = Math.ceil(2.45); //r = 3.0
                        double p = Math.floor(2.45); //p = 2.0
                        double q = Math.floor(2.99); //r = 2.0
        pow() - exponents
                Takes any number, returns double
                Example:
                        double p = Math.pow(2, 5); //p = 32.0
                        double q = Math.pow(25, 0.5); //q = 5.0
        random numbers
                Example:
                        double ran = Math.random();
                        => random number between 0 and 1.0 (not included - exclusive)
