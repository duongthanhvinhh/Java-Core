1. Can have multiple class in a java class file, but only one class in top-level, means only one class can be public. the others can not be given the public access modifier.
2. public void setName(String name) => the setName(String name) is called signature (signature includes the method name and the argument of the method)
3. java FodenClass "Foden" Foden  => input "Foden" or Foden can both be ok with java runtime
4. import java.util.* will import all classes under java.util, but not import subfolder of util folder
5. can compile multiple java class in one command: javac packagea/*.java packageb/*.java
6. if want to compile java file to class file and stored in another folder name classes: javac -d classes packagea/*.java packageb/*.java
7. to run the class files in 6:
    java -cp classes packagea.nameOfOneClassFileWithoutExtension
    or
    java -classpath ............................................
    or
    java --class-path ..........................................
8. java -cp ".;C:\com\demo\deps;C:\com\demo\myJar.jar" myPackage.MyApp
    To understand the above command, see below:
    C:\
     └── com\
         └── demo\
             ├── deps\
             │   ├── libA.jar
             │   └── libB.jar
             ├── myJar.jar
             │   └── myPackage\
             │       └── MyApp.class
             └── main.class
     first java to start jvm to execute java application
     second -cp to define classpaths, which is the path to the class files and Jar files that the application will need. The classpath contains multiple paths, separated by <;> semicolon (on Windows) or <:> colon on Unix/Linux
     third is class path: the first <.> represents the current directory which you are executing the command. Java will treat current folder as a base directory
                          C:\com\demo\deps This is the path to a directory that contains dependency libraries that MyApp need (libA.jar and libB.jar)
                          C:\com\demo\myJar.jar This is a specific jar file that contains compiled source code. For example, this file might contain some classes that your application uses
     Last is myPackage.MyApp This is the full name of the class. MyApp must have a method public static void main(String[] args) for java to know where to start.
9. Create your own jar file (from files in current folder)
    jar -cvf myNewJarFile.jar .
    or
    jar --create --verbose --file myNewJarFile.jar .
10. Create your own jar file (from files in custom folder)
    jar -cvf myNewJarFile.jar -C myFolder
    or
    jar --create --verbose --file myNewJarFile.jar -C myFolder
11. Foden foden = new Foden(); => In Java, when you create an instance of a class, the static blocks are executed only once when the class is loaded into memory,
                                  before any instances of the class are created. So, when you execute Foden foden = new Foden(); any static block in the Foden class
                                  will run before the constructor of Foden is executed.
12. Primitive Types:
    Definition: These are the basic data types provided by Java. They hold their values directly and are not objects.
    Characteristics:
            Fixed size.
            Stored in the stack memory.
            Represent simple values.
            Cannot be null.
    boolean: Type true or false, default value is false
    byte: 8bit integral value, from -128 to 127, default value is 0
    short: 16bit integral value, from -32,768 to 32,767, default value is 0
    int: 32bit integral value, from -2,147,483,648 to 2,147,483,647, default value is 0
    long: 64bit integral value, from -2^63 to 2^63 - 1, default value is 0L, example value is 5106L
    float: 32bit floating value, default value is 0.0f, example value is 511.183f
    double: 64bit floating value, default value is 0.0, example value is 511.183
    char: 16bit unicode value, from 0 to 65,535, default value is \u0000, example value is 'C'
    => To keep in mind:
        in Java, boolean true and false are completely unrelated to 1 and 0
        all numeric types are signed (allow negative numbers)
        float requires f (or F) at the end
            float x = 2.7; // Does not compile
            float x = 2.7f; // OK
        long requires l (or and preferably L) at the end
            long a = 45366546327; // Does not compile
            long a = 45366546327L; // OK
        for readability the use of underscore (_) is allowed, but NOT in the beginning or the end
            int a = 1_000_000; // normal usage
            int b = 1_2; // OK, but not very useful
            int c = 1________2; // even less useful, but still OK
            double d = 1_000_000.000_001 // OK and makes sense
            double x = _10.1; // NOK, do not allowed underscore at the beginning or the end
13. Non-Primitive Types:
    Definition: These are more complex data types that are derived from primitive types. They can hold multiple values and are always objects.
    Characteristics:
            Variable size.
            Stored in the heap memory.
            Can represent collections of values or complex data.
            Can be null.
    Strings: are not primitive types in Java, but they are commonly use like primitive
            String greeting = "hello world";
            ......................
            ......................
            ...Tobe continued.....
14. Stack and Heap memory:
    Stack:
        Definition: The stack is a region of memory that stores temporary variables created by each method (function) call. It operates in a last-in, first-out (LIFO) manner.
        Characteristics:
                Storage of Local Variables: Stack memory is used for storing local variables, method parameters, and references to objects in the heap.
                Automatic Memory Management: Memory is automatically allocated and deallocated. When a method is called, a new block (frame) is created on the stack.
                                             When the method returns, its frame is removed.
                Limited Size: Stack memory is generally smaller than heap memory. Its size is defined at the start of the application and can lead to a StackOverflowError
                              if too much memory is used (e.g., in deep recursion).
                Fast Access: Accessing data from the stack is faster than from the heap due to its structured nature.
        Example:
            public class StackExample {
                public static void main(String[] args) {
                    int localVariable = 10;  // Stored in stack
                    anotherMethod();
                }

                public static void anotherMethod() {
                    int anotherVariable = 20; // Also stored in stack
                }
            }
    Heap:
        Definition: The heap is a region of memory used for dynamic memory allocation, where objects are stored. It is managed by the Java Virtual Machine (JVM).
        Characteristics:
                Storage of Objects: All Java objects and their instance variables are stored in heap memory.
                Dynamic Allocation: Memory can be allocated and deallocated dynamically at runtime using the new keyword.
                                    Unlike the stack, memory in the heap is not automatically freed when a method exits.
                Garbage Collection: The JVM includes a garbage collector that automatically reclaims memory used by objects that are no longer referenced,
                                    helping to prevent memory leaks.
                Larger Size: Heap memory is generally larger than stack memory, allowing more significant data storage.
                             However, accessing heap memory can be slower than stack memory due to the overhead of memory management.
        Example:
            public class HeapExample {
                public static void main(String[] args) {
                    MyObject obj = new MyObject(); // obj is a reference stored in the stack, new object of MyObject is in the heap
                }
            }

            class MyObject {
                int value;

                MyObject() {
                    value = 10; // Instance variable stored in heap
                }
            }
15. Text Blocks: Is a new feature in Java 15
    i.e
        The old way: String title = "\"Java Core\"\n    by Foden Duong";
        String title = """
            "Java Core"
               by Foden Duong""";
        //The output:
            "Java Core"
               by Foden Duong
    => Remember, after the first """, should be the new line
       and after the second """, can be the new line or the same line but recommended the new line if you want compiler to insert a new line
       Any whitespace before the first non-empty character in the line after the 1st """ will be ignored by compiler.
       Compiler looks for the first non-empty character.
       But once the compiler finds the first non-empty character, then these spaces (before by Foden Duong""") will be essential,
       so these are part of the string.
16. Variables: is a name for a piece of memory which stores data
    To declare a variable: int x;
    To initialize a variable: int x = 5;
    Name of the variable (method, class, interface, package, ...) is called identifier
    Identifier rules:
        Must begin with a letter, currency symbol ($, ...), or underscore(_)
        Can include numbers, but not start with a number
        Single underscore(_) is not allowed as an identifier
        You cannot use the reserved word (like: abstract, case, continue, super, import, return, volatile, goto,...)
    Naming conventions:
        For variables, use camelCase
        For constants, use SNAKE_CASE
        Identifier of classes, interfaces, enums records start with first uppercase letter (e.g MyClass, MyInterface, StudentRecord)
        Identifiers variables and methods start with first lowercase letter (e.g fullName, getFullName())
        => Java identifier are case-sensitive !!
    Multiple variables can be declared/initialized in a single line (bad practice, but it compiles)
        int x, y;
        String firstName = "Foden", lastName = "Duong";
        boolean v = true, w, z = false;
    but you  cannot mix types (cannot declare variables of different type in a single line)
        int x, String name; // DOES NOT COMPILE
        or
        int x,
            String name: // "This is same line, as Java seperate lines by semicolon (;)", so DOES NOT COMPILE
    Three kinds of variables:
        Local variable - exist only within the block of code { ... }
        Instance variables (fields) - defined within the specific instance of the object
        Class variables - belong to a class and is shared with all instances of the class(marked with keyword static)
    Instance and class variables don't require initialization
        In-case you don't initialize variable, java will assume the defaults values of their type (i.e for doubles type, the default value is 0.0)
    Local variables must be initialized before use
        public int doesNotcompile(){
            int a = 3;
            int b;
            return a + b; // DOES NOT COMPILE as we use b but do not initialize it yet
        }
        but
        public int doesCompile(){
            int a = 5;
            int b = 3;
            int c;
            return a + b; // COMPIlE because c is not initialized but it's never used
        }
    Be careful if initialization is within if-statement
            public void doesNotCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5; // might never be reached
                }
                System.out.println(a); // DOES NOT COMPILE, variable a might not have been initialized
            }
            but
            public void doesCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5;
                } else {
                    a = 2;
                }
                System.out.println(a); // COMPILE, because this variable a will be initialized one way or another
            }
    Final variables (constants)
        final int MAX_HEIGHT = 100;
        Final can be applied to a reference:
            final int[] MY_NUMBERS = new int[5];
            in this case, reference cannot be modified, but the content of the object can:
                        MY_NUMBERS[2] = 10; // OK
                        MY_NUMBERS = null; // DOES NOT COMPILE as you are trying to modified the reference
    Variable scope:
        Local variable: in scope from { to }
        Method parameters: in scope for the duration of the method
        Instance variable: in scope from declaration until the object is eligible for garbage collector
        Class variables: in scope from declaration until the program ends
17. Arguments and parameters in Java (Đối số và tham số trong Java):
    public void greeting(String message){ // message is parameter
        System.out.println(message);
    }
    greeting("Welcome to Java Core"); // Welcome to Java Core is argument
    => Tham số (parameter) được định nghĩa trong hàm
       Đối số (argument) là giá trị truyền vào khi gọi hàm
18. Call by value and call by reference:
    In Java, the distinction between call by value and call by reference is important to understand, especially when working with primitive types and objects.

    Call by Value
        In Java, all method arguments are passed by value. For primitive types (like int, float, etc.), a copy of the value is passed to the method.
        Changes made to the parameter do not affect the original variable.
        Example (Primitive Type):
            public class CallByValue {
                public static void increment(int x) {
                    x += 1;  // Changes the local copy only
                }

                public static void main(String[] args) {
                    int num = 5;
                    increment(num);
                    System.out.println(num);  // Output: 5 (original value remains unchanged)
                }
            }

    Call by Reference (for Objects)
        While Java does not support true call by reference, it passes object references by value.
        This means that a copy of the reference (pointer) to the object is passed.
        If you modify the object using this reference, the changes will be reflected in the original object.
        Example (Object Type):
            class MyClass {
                int value;
                MyClass(int value) {
                    this.value = value;
                }
            }
            public class CallByReference {
                public static void modify(MyClass obj) {
                    obj.value += 1;  // Changes the object referenced
                }
                public static void main(String[] args) {
                    MyClass myObj = new MyClass(5);
                    modify(myObj);
                    System.out.println(myObj.value);  // Output: 6 (original object is modified)
                }
            }
    Summary
    Call by Value: For primitives, a copy of the value is passed; changes do not affect the original variable.
    Call by Reference (for Objects): A copy of the reference to the object is passed; changes to the object affect the original object.
19. Local variable reference type:
        Example:
            var a = 5; //Compiler will automatically figure out the type of a is int based on the value you passed
            But
            var a = "Foden"; //DOES NOT COMPILE if put this line in the same scope of the above line. It means when the compiler figure out the type of variable,
                                we cannot reassign the type of it
            And we cannot use local variable reference type for null value
                var a = null; DOES NOT COMPILE
        Remember, var is not a reserved word (not like int, final,...), so we can create class, or method name Var
            public class Var {} //OK
            or
            var var = 5; //OK
            or
            Var var = new Var(); //OK
        Remember, it's only work for local variable
            public int sum (var a, var b){
                return a + b;
            } //DOES NOT COMPILE > as it is only work for local variable, not method variable
        Practical usage:
            Old way:
                ClassWithALongName myInstance = new ClassWithALongName();
                or
                ClientList<Client> clientList = new ClassWithALongName.getClientList();
            New way:
                var myInstance = new ClassWithALongName();
                or
                var clientList = new ClassWithALongName.getClientList();
20. Garbage Collection:
        All Java objects are stored in program's heap memory (aka free store)
        Garbage collection is just a process of automatically freeing memory on the heap
            By removing all the objects which are no longer reachable by the program (Objects are eligible for Garbage collection)
            This process is out of our control, it's for java to handle automatically
        There is a system method to force this process : System.gc(); // with this method you can suggest java to clean the heap
            But it's not guaranteed to do anything !! You can hope that Java will clean the heap, but you can not be guaranteed that Java will do anything
        Example:
            public class GcExample {
                public static void main(String[] args){
                    String a, b;
                    a = new String("Foden");
                    b = new String("Duong");
                    a = b;
                    String c = a;
                    a = null;
                }
            }
            Explain:
                        Reference (Stack memory)                    Object (Heap memory)
                    a ---------------------Reference a is pointed to object "Foden"-------------> "Foden"
                    b ---------------------Reference b is pointed to object "Duong"-------------> "Duong"
                    a = b, so now ---------Reference a is pointed to the object that is refered by b, that's "Duong"
                    now a is pointed to object "Duong" and no longer refered to "Foden",
                    then now "Foden" is eligible for Garbage collection and be removed from Heap memory
                    then String c = a -----c now is pointed to the object "Duong" which is also pointed to by a
                    then a = null, a no longer pointed to object "Duong" and now having value null
21. Operators
        There are 3 types of operators in Java:
            Unary operator: = Requires only one operator
                i++; Increases value by 1 and then return the OLD value
                    Example:
                        int a = 5;
                        int b = a++;
                        System.out.println(a); // = 6, because a++ increase value of a by 1
                        System.out.println(b); // still  = 5, because a++ increase value of a by 1, but return the OLD value, then it's 5
                ++i; Increases value by 1 and then return the NEW value
                    Example:
                        int x = 1;
                        int y = ++x*2
                        => y = (++x) * 2;
                        => y = 2 * 2
                        => y = 4;
            Binary operator:
                Addition: a + b;
                Subtraction: a - b;
                Multiplication: a * b;
                Division: a / b;
                Modulo operator: a % b;
                    Example:
                        11 / 2 = 5 (FLOOR value)
                        11 % 2 = 1 (Remainder of division)
                    Java promotes variable type, example:
                        short x = 5;
                        short y = 7;
                        System.out.println(x + y); // x and y are promoted to int, the result is int = 12
                        But
                        short z = x + y; //DOES NOT COMPILE as you try to put int to short
            Ternary operator:
                a = (b > 0) ? 3 : 4;
        Java automatically promotes smaller to larger data type
            Example:
                short x = 5;
                int y;
                y = x; //OK (x is casted to int )
            But can not do it in vice verse
            Example:
                int x = 5;
                short y;
                y = x; //DOES NOT COMPILE as you try to put int in short
                but, to have it work, you can cast type
                y = (short) x; //OK
        Expression a = 2 do 2 things:
            First, assign value 2 to a
            Second return value 2
            Example:
                int x = 5;
                int y = (x = 3) * 2;
                => x = 3; y = 6
        Favourite exam trick:
            boolean isOK = false;
            if(isOK = true){ // here the assignment operator = , not comparison operator == , so isOK is assigned to new value is true, the "true" will be printed out in the console
                System.out.println("true");
            } else {
                System.out.println("false");
            }
        Comparison operators
            Example:
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = name1;
                System.out.println(name1 = name2); //false because name1 and name2 are pointed to different object in the heap
                System.out.println(name1 = name3); //true because name1 and name3 are pointed to same object in the heap
22. Switch Statement:
        Default could be  anywhere in the block
        Be careful if there are no break statement:
            public void greeting(int a){
                switch(a){
                    case 1:
                        System.out.println("One");
                    default:
                        System.out.print("Maximum");
                    case 2:
                        System.out.print("Two");
                    case 3:
                        System.out.print("Three");
                }
            }
            greeting(5);// The results will be: Maximum Two Three, because there no break so after the default, it will execute all the case after default
23. Switch Expression:
        Java 8:
                    public void greeting(int a){
                        switch(a){
                            case 1:
                            case 2:
                            case 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Java 17:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Another improvement in Java 17, using -> instead of : then you don't need break statement anymore:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3 -> System.out.print("In first three int numbers");
                            case 4, 5, 6 -> {
                                System.out.println("In first three int numbers");
                                System.out.println("Multiple command should be placed in {}");
                            }
                            default -> System.out.print("Not in first three int numbers");
                        }
                    }
        Real improvements, Switch statement can be treated as an expression:
                String alarmMeAboutNumber = switch(a){
                              case 1, 2, 3 -> "In first three int numbers";
                              default -> "Not in first three int numbers";
                          }; // need ; at the end because this is expression returns a string
        We can use yield keyword (similar to return statement in methods)
                Example:
                    int a = 1;
                    String greeting = switch(a) {
                                        case 0, 1, 2 -> {
                                            String str1 = "Good";
                                            String str2 = " day";
                                            yield str1 + str2;
                                        }
                                        case 3, 4 -> "Hi";
                                        default -> "Hello";
                                       };
                    System.out.println(greeting); // output is : Good day
                Another example:
                    public void greet(int a, int b){
                        String greeting = switch(a) {
                            case 0 -> "Good morning";
                            case 1 -> {
                                if(b > 0) yield "Good morning";
                                    else yield "Good afternoon";
                            }
                            case 2 -> "Hi";
                            default -> "Hello";
                        };
                        System.out.println(greeting)
                    }
                    greet(1, -1); // output is : Good afternoon
        Switch expression can return different value types:
            Example:
                public void greet(int a){
                    var printOut = switch(a){
                        case 0 -> "Good morning" //String
                        case 1 -> 5; //int
                        case 2 -> true; //boolean
                        default -> 3.14 //double
                    }
                }
        Switch expression must handle all possible cases -> it means the DEFAULT statement is REQUIRED (except for enum case)
        If we use enums, we can just list all possible values
            Example:
                enum Compass {NORTH, SOUTH, EAST, WEST}
                String getDirection(Compass value){
                    return switch(value){
                        case NORTH -> "Up";
                        case SOUTH -> "Down";
                        case EAST -> "Right";
                        case WEST -> "Left";
                    }
                }
                System.out.println(getDirection(Compass.SOUTH));
24. While Loop
        Using break in nested loops, with labels: To stop outer loop in case you're in inner loop
            Example:
                int i = 0; j = 0;
                OUTER_LOOP: while(true){
                    i++;
                    j = 0;
                    INNER_LOOP: while(true){
                        j++;
                        System.out.print("(" + i + "," + j + ")");
                        if(j == 3) break OUTER_LOOP; //break will turn into label OUTER_LOOP, then the outer loop will be ended.
                                                     //Output is (1,1), (1,2), (1,3)
                    }
                }
        or
        use return; to terminate the method
            Example:
                public void printPairs(){
                    int i = 0; j = 0;
                    OUTER_LOOP: while(true){
                        i++;
                        j = 0;
                        INNER_LOOP: while(true){
                            j++;
                            System.out.print("(" + i + "," + j + ")");
                            if(j == 3) return; //exist the method
                        }
                    }
                }
                printPairs(); //Output is (1,1), (1,2), (1,3)
25. For Loop:
        Can omit any one of the statements but still have to keep ; in place
        Infinite loop
             for( ; ; ){}
        You can use more than one index in a for loop, separated by comma
            for(int i = 0, j = 0; (i + j) < 5; i++, j++) {
                System.out.println("i=" + i + ", j=" + j);
                //output;
                    i=0, j=0
                    i=1, j=1
                    i=2, j=2
            }
26. For-Each Loop:
        Is often used to access the members of array (or collection, when you don't need access the index of member actually)

27. String
    String is a sequence of characters, implementing CharSequence interface:
    String name = "Foden";
    String name = new String("Foden");
    Concatenation:
            str1 + str2
        or
            str1.concat(str2)
        If both operands are numeric, + mean addition
        If either operand is String, + means concatenation
        Evaluation is left to right -> System.out.println("Foden" + 4 + 6); //Output is Foden46
                                       System.out.println("Foden" + (4 + 6)); //Output is Foden10
        It's allowed to concatenation with null string -> System.out.println("Foden" + null); //Output is Fodennull
    String Methods:
        length():
                String name = "Foden"; -> System.out.println(name.length()); //Output is 5
        charAt():
                String name = "Foden Duong"; -> System.out.println(name.charAt(6)); //Output is D (index start from 0, so char at index 6 is D)
                                             -> System.out.println(name.charAt(17)); //Output is StringIndexOutOfBoundException
        indexOf():
                String name = "Doctor Dolittle";    -> System.out.println(name.indexOf('t')); //Output is 3, start finding from index 0, and return the first index of character what is being searched
                                                    -> System.out.println(name.indexOf('t', 5)); //Output is 11, because start to find from index 5, so the t at index 3 will be ignored
                                                    -> System.out.println(name.indexOf("cto")); //Output is 2 that is the index of first character of string "cto"
                                                    -> System.out.println(name.indexOf("Do", 4)); //Output is 7
                                                    -> System.out.println(name.indexOf("A")); //Output is -1 , means not found
        substring():
                String name = "Foden Duong";    -> System.out.println(name.substring(4)); //Output is n Duong (includes start index to the end of string)
                                                -> System.out.println(name.substring(4, 8)); //Output is n Du (includes start index but does not include end index)
                                                -> System.out.println(name.substring(4, 4)); //Output is (output is empty string)
                                                -> System.out.println(name.substring(8, 4)); //Output is IndexOutOfBoundsException
                                                -> System.out.println(name.substring(4, 14)); //Output is IndexOutOfBoundsException
        toLowerCase():
                String name = "Foden Duong"; -> System.out.println(name.toLowerCase()); //Output is foden duong
        equals(), equalsIgnoreCase():
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = new String("foden Duong");
                System.out.println(name1 == name2); //false, because they are not referencing to the same object
                System.out.println(name1.equals(name2)); //true, because same content
                System.out.println(name1.equals(name3)); //false, because String is case-sensitive
                System.out.println(name1.equalsIgnoreCase(name3)); //true, method equalsIgnoreCase will ignore case sensitive
        startsWith(), endsWith():
                String name = "Foden Duong";
                System.out.println(name.startsWith("F")); //true
                System.out.println(name.startsWith("Fod")); //true
                System.out.println(name.endsWith("g")); //true
                System.out.println(name.endsWith("Duong")); //true
                System.out.println(name.startsWith('F')); //DOES NOT COMPILE, because argument must be a string, not char !
        contains():
                String name = "Foden Duong";
                System.out.println(name.contains("n")); //true
                System.out.println(name.contains('n')); //DOES NOT COMPILE, because string implements CharSequence, single quotes for char do not create a CharSequence, then compile error.
                                                        //need to pass a string or a single charater within double quote ""
                System.out.println(name.contains("en D")); //true
                System.out.println(name.contains("m")); //false
        replace():
                String str = "abcdeabc";
                System.out.println(str.replace('c', 'y')); //Output is abydeaby (replaces all instances of 'c' with 'y')
                System.out.println(str.replace("c", "y")); //Output is abydeaby (parameters can be both string and char)
                System.out.println(str.replace("abc", "fod")); //Output is foddeabc
        strip(), trim(), stripLeading(), stripTrailing():
                String str = " abc ";
                System.out.println(str.strip()); //Output is abc (strip() removes whitespaces at the beginning and the end, also supports unicode whitespace. It is a recommended way to use in case wanna remove whitespace at beginning and the end)
                System.out.println(str.trim()); //Output is abc (works same as strip() but does not support unicode whitespace)
                System.out.println("|" + str.stripLeading() + "|"); //Output is |abc | (remove the whitespaces at the beginning)
                System.out.println("|" + str.stripTrailing() + "|"); //Output is | abc| (remove the whitespaces at the end)
        indent(n) method:
                If n = 0 does nothing
                If n > 0 adds the same number of blank spaces to each line
                If n < 0 tries to remove n whitespace characters from the beginning of line
                Normalizes existing line breaks
                Adds line break at the end if missing
        stripIndent() method:
                Removes all leading incidental whitespace
                Normalizes existing line breaks
                Does not add line break at the end if missing
                    Example for indent(n) and stripIndent():
                        String str = "  Foden\n Duong";
                        System.out.println(str); Output is:  Foden
                                                            Duong
                        System.out.println(str.indent(2)); //Add 2 whitespaces add the beginning of each line Output is:    Foden
                                                                                                                           Duong
                        System.out.println(str.indent(-2)); //Remove 2 whitespaces add the beginning of each line Output is:  Foden
                                                                                                                             Duong
                        System.out.println(str.stripIndent()); //Remove all whitespaces of line having total of whitespaces is min, and remove that of whitespace for other lines ,
                                                               //in this case remove all spaces at the beginning of line Duong, and remove total of that whitespaces in line Foden Output is: Foden
                                                                                                                                                                                             Duong
        translateEscapes():
                String name = "Foden\\tDuong";
                System.out.println(name); //Output is Foden\tDuong (first t supports to escapes second t, then \t will be printed out)
                but
                System.out.println(name.translateEscapes()); //Output is Foden Duong (translateEscapes() method will support to understand the \t, then \t will be treated as a tab)
        isEmpty(), isBlank():
                System.out.println("".isEmpty()); //true
                System.out.println(" ".isEmpty()); //false, because it is not empty
                System.out.println("".isBlank()); //true
                System.out.println(" ".isBlank()); //true
        String formating symbols:
                %s for any type, usualy for String
                %d for integral values (int and long)
                %f for decimal numbers (float and double)
                    Example:
                        String name = "Foden";
                        int numberOfMembers = 5;
                        String printOut1 = "Family of " + name + " has " + numberOfMembers + " members.";
                        String printOut2 = String.format("Family of %s has %d members.", name, numberOfMembers);
                        String printOut3 = "Family of %s has %d members.".formatted(name, numberOfMembers);
                        => The 3 ways above gives the same result.
        Method chaining:
                left -> right
                String name = " Foden Duong ";
                System.out.println(name.trim().toUpperCase().replace('F','M')); //Output is Moden Duong
                !!!Strings are immutable
                String name = "Foden Duong";
                name.toUpperCase();
                System.out.println(name); //Output is still Foden Duong, because string is immutable, so the original value of string will be kept the same
                But
                name = name.toUpperCase();
                System.out.println(name); //Output now is FODEN DUONG
        String builder:
                StringBuilder is a mutable class which contains a String
                It has many methods for manipulating the strings
                    Example:
                        StringBuilder name = new StringBuilder("Foden Duong");
                Some methods work in the identical way as with a normal String substring(), indexOf(), length(), and charAt()
                Methods:
                        1. append():
                                StringBuilder name = new StringBuiler("Foden");
                                name.append("Duong");
                                System.out.println(name); //Output is FodenDuong (name is changed now, so can say StringBuilder is mutable)
                           chaining with append():
                                name.append(1).append(true);
                                System.out.println(name); //Output is FodenDuong1true (all arguments are converted to String)
                        2. insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. "); //insert to index 5 the Mr.
                                System.out.println(name); //Output is Foden Mr. Duong
                           chaining with insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. ").insert(6, "A"); //be careful, the first insert() will be performed in the original string, but the second insert will be performed in the new string after the first insert completed
                                System.out.println(name); //Output is Foden AMr. Duong
                        3. delete():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.delete(1, 4)); //Output is Fn Duong (remove all characters from 1 to 4, but exclude 4)
                        4. deleteCharAt():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.deleteCharAt( 4)); //Output is Fod Duong (remove character at index 4)
                                System.out.println(name.deleteCharAt( 15)); //Output is StringIndexOutOfBound
                        5. replace():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.replace(0, 4, "Vinh")); //Output is Vinhn Duong (will replace string from 0 to index 4 - 1 = 3 by Vinh)
                                    If final index is too large, replace goes through the end (no exception !!)
                                        StringBuilder name = new StringBuilder("Foden Duong");
                                        name.replace(6, 100, "Vinh");
                                        System.out.println(name); //Output is Foden Vinh
                        6. reverse():
                                StringBuilder name = new StringBuilder("FODEN");
                                name.reverse();
                                System.out.println(name); //Output is NEDOF
                        7. toString():
                                StringBuilder name = new StringBuilder("FODEN");
                                String nameInString = name.toString();
                        8. equals():
                                => Remember StringBuilder doesn't implement equals() method, so if you use equals() for a string builder, it will treat as ==,
                                => then compiler will compare the references and if the reference is point to different object, it will be false
                                    Example:
                                        StringBuilder name1 = new StringBuilder("FODEN");
                                        StringBuilder name2 = new StringBuilder("FODEN");
                                        System.out.println(name1 == name2); //false
                                        System.out.println(name1.equals(name2)); //false as well, because StringBuilder doesn't implement equals() method, the it will treat equals() as ==
                                => !!! So if we want to compare content we have to convert it back to String:
                                        System.out.println(name1.toString().equals(name2.toString())); //Output is true
                        9. substring():
                                => StringBuilder is mutable class, but there is one exception: substring() returns a String and doesn't change the StringBuilder
                                        Example:
                                            StringBuilder name = new StringBuilder("Foden Duong");
                                            name.substring(6, 11);
                                            String subName = name.substring(6, 11);
                                            System.out.println(name); //Output is still Foden Duong (so StringBuilder.substring() is immutable - exception one)
                                            System.out.println(subName); //Output is Duong

28. String pool (or intern pool):
    When creating a new string with literal value "Foden", JVM stores it in the memory location known as String pool or intern pool (part of heap memory)
    Now creating a new string with same literal value "Foden", instead of creating a new memory spot for this literal value, JVM will look in the String pool,
        then it finds that literal already exists, it will point the new variable to the existing location in the String pool
    Example:
        String str1 = "Foden";
        String str2 = "Foden";
        System.out.println(str1 == str2); //true, because same content and point to the same location in String pool
        System.out.println(str1.equals(str2)); //true, equals only compare the content of these 2 strings
    But, tricky example #1
        String str1 = "Foden";
        String str2 = "   Foden  ".trim();
        System.out.println(str1 == str2); //false, because pool is created at compile-time, but trim() is evaluated at run-time
    Or even like this, it's still false
        String str1 = "Foden";
        String str2 = "   Foden  ";
        str2 = str2.trim();
        System.out.println(str2); //Output here is Foden, but the below line still getting false, because pool is created at compile-time, but trim() is evaluated at run-time
                                  //More explanation: During compile time, compiler will check 2 strings str1 = "Foden" and str2 = "   Foden  ", it sees that these 2 strings are
                                  //different, then it will assign them to 2 different memory spots in String pool, that's why even after trim(), str2 now is "Foden", but we still
                                  //get false when trying to compare str1 == str2
        System.out.println(str1 == str2);
    Tricky example #2
        String str1 = "Foden Duong";
        String str2 = "Foden" + " " + "Duong";
        System.out.println(str1 == str2); //true, because the concatenation is done in the compile-time
    There's way to get true in the tricky example #1: That is instruct the compiler to use the pool even with runtime methods
        String str1 = "Foden";
        String str2 = "   Foden  ".trim().intern(); //use intern() to tell the compiler that need to evaluate the trim() method
        System.out.println(str1 == str2); //true
29. Arrays
    Many ways to initialize an array:
            int[] nums = new int[3]; //declare first
            nums = new int[]{2, 1, 3}; //initialize later
        or
            int[] nums = new int[]{2, 1, 3};
        or
            int[] nums = {2, 1, 3};
    Can have multiple values in one declaration but not recommended:
            int[] nums, ages; // 2 arrays declared
        or
            int nums[], a; // 1 array and 1 int number declared
    Arrays don't implement equals() method, so if you use equals(), it will be treated as == comparison
    Printing out the array:
            int[] nums = {2, 1, 3};
            System.out.println(nums); //Output will something like this I@7a4f0f29, this is the hash code of reference nums.
        so to print out the array:
            System.out.println(Arrays.toString(nums)); //Output is [2, 1, 3]
    Every array has a property called length (It is a property, not a method)
            int[] nums = {2, 1, 3};
            System.out.println(nums.length); //Output is 3
    Methods of Arrays:
        Arrays.sort():
                int[] nums = new int[] {2, -4, 7, 17};
                Arrays.sort(nums);
                System.out.println(Arrays.toString(nums)); //Output is [-4, 2, 7, 17]
                => !!! Arrays are mutable,sort() changes the original array.
        Arrays.binarySearch():
                Works only on sorted arrays
                If array is not sorted, then the result is unpredictable
                This method takes array and array elements as arguments,
                    if element is found, the index of that element is returned
                    if element is not found, the negative number is returned -(index_where_it_would_belong + 1)
                Example:
                    int[] nums = new int[] {3, -1, 8};
                    Arrays.sort(nums); // sort array to have binarySearch() works, now array is {-1, 3, 8}
                    System.out.println(Arrays.binarySearch(nums, -1)); //Output is 0, the index of -1
                    System.out.println(Arrays.binarySearch(nums, 1)); //Output is -2, why ? if 1 exists in the array, then it should be index 1 => -(index_where_it_would_belong + 1) = -(1 + 1) = -2
        Arrays.compare():
                This method determines which array is smaller and returns:
                    Negative number if first array is smaller than second array
                    Zero number if the arrays are the same contents
                    Positive number if first array is larger than second array
                Definition of what is smaller here:
                    If one array has less number of elements than another, it's smaller
                    If both arrays have same number of elements:
                        Smaller is the one whose first different member is smaller
                        Example:
                            int[] nums = new int[] {3, -1, 8};
                            int[] nums1 = new int[] {3, -2, 8};
                            => then nums1 is smaller than nums
                        For Strings:
                            One is smaller if it is a prefix of another
                            Numbers are smaller than letters (i.e "232" is smaller than "Fo")
                            Uppercase is smaller than lowercase
                            Alphabetical order is applied
                    Null is smaller than any other values

                Some examples:
                    Arrays.compare(new int[]{3, 7}, new int[]{4}); => returns positive number, because first array has more elements than second one
                    Arrays.compare(new int[]{3, 7}, new int[]{3, 7}); => returns 0, because these 2 arrays has the same content
                    Arrays.compare(new String[]{"ab", "sdfs"}, new String[]{"abs", "shtr"}); => returns negative number, because first elements are different, can see "ab" is prefix of "abs",
                                                                                                then first array is smaller than second one
                    Arrays.compare(new String[]{"xy", "sdfs"}, new String[]{"abc", "shtr"}); => returns postive number, because first elements are different, can apply alphabetical order here,
                                                                                                because "x" is after "a", means "abs" is smaller than "xy", then means first array is larger than second array
                    Arrays.compare(new String[]{"Foden", "John"}, new String[]{"foden", "Duong"}); => returns negative number, because UpperCase is smaller than lowercase
        Arrays.mismatch():
                This method returns -1 if array are the same content, otherwise returns the first index where they differ
                Example:
                    Arrays.mismatch(new String[]{"Foden", "Duong"}, new String[]{"Foden", "Vinh"}); => return 1, that is the index of second element where they differ
    Multidimensional arrays:
        This is array of arrays:
        Example:
            int[][] a = {
                {-1, 3},
                {5},
                {45, 7, -2},
                {32, 6, 3, 11}
            }; => This array a has 4 elements type array, first element is an array has 2 element -1 and 3, ... so on
        Accessing elements with traditional loop:
            for(int i = 0; i < a.length; i++){
                for(int j = 0; j < a[i].length; j++){
                    System.out.println("a(%d, %d) = %d".formatted(i, j, a[i][j])); i is row, j is index in row = j is column
                }
            }
            The result like:
                a(0,0) = -1
                a(0,1) = 3
                a(1,0) = 5
                a(2,0) = 45
                ...........
        Accessing elements with for-each loop:
            for(int[] row : a){
                for(int column : row){
                    System.out.println("Element = " + element);
                }
            }
            The result like:
                Element = -1
                Element = 3
                Element = 5
                Element = 45
                ............
30. Dates and Times: Creating Date and Time, Methods on Dates and Times
            import java.time.*;  //If only use LocalDate, LocalTime, and LocalDateTime
            import java.time.temporal.*; //Import this one if you want to use chronounits
            public class DatesAndTimes {

                public static void main(String[] args) {
                    LocalDate localDate = LocalDate.now();
                    LocalTime localTime = LocalTime.now();
                    LocalDateTime localDateTime = LocalDateTime.now();
                    ZonedDateTime zonedDateTime = ZonedDateTime.now();
                    System.out.println(localDate);      //Output is: 2024-10-26
                    System.out.println(localTime);      //Output is: 22:46:33.977090400
                    System.out.println(localDateTime);  //Output is: 2024-10-26T22:46:33.977090400
                    System.out.println(zonedDateTime);  //Output is: 2024-10-26T22:46:33.978089600+07:00[Asia/Bangkok]

                    Creating local date: 2 ways
                            LocalDate d1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalDate d2 = LocalDate.of(2024, 10, 26);
                            System.out.println(d1); //Output is: 2024-10-26
                            System.out.println(d2); //Output is: 2024-10-26 (same as the way above using for creating d1)

                    Creating local time: Many ways to do that
                            LocalTime t1 = LocalTime.of(22, 52);
                            LocalTime t2 = LocalTime.of(22, 52, 38);
                            LocalTime t3 = LocalTime.of(22, 52, 38, 131);
                            System.out.println(t1); //Output is: 22:52
                            System.out.println(t2); //Output is: 22:52:38
                            System.out.println(t3); //Output is: 22:52:38.000000131

                    Creating local date-time: Many ways to do that
                            LocalDateTime dt1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 22, 55, 59); //yyyy, mm, dd, hh, mm, ss
                            LocalDate ld1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalTime lt1 = LocalTime.of(22, 55, 59);
                            LocalDateTime dt2 = LocalDateTime.of(ld1, lt1);
                            System.out.println(dt1); //Output is: 2024-10-26T22:55:59
                            System.out.println(dt2); //Output is: 2024-10-26T22:55:59 (same as above)

                    Creating zoned date-time:
                            ZoneId zoneId = ZoneId.of("Europe/Zagreb");
                            ZonedDateTime z1 = ZonedDateTime.of(2024, 10, 26, 23, 2, 19, 32,zoneId); //yyyy, mm, dd, hh, mm, ss, nano second, zoneId
                            System.out.println(z1); //Output is: 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb]
                             ==> +02:00 in the output means that the local time Europe/Zagreb is 2 hours ahead of UTC (Coordinated Universal Time) or aka GMT (Greenwich Mean Time)
                             ==> If UTC/GMT time is now 1PM, then at Europe/Zagreb it should be 3PM

                    For the exam, you need to know how to convert between time-zones:
                             ==> 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb] should be 2024-10-26T21:02:19.000000032 in UTC/GMT
                             ==> 2024-10-26T23:02:19.000000032-02:00[Europe/Zagreb] should be 2024-10-27T01:02:19.000000032 in UTC/GMT

                    Date-Time Methods:
                            LocalDate, LocalDateTime
                                plusYears(), plusMonths(), plusWeeks(), plusDays()
                                minusYears(), minusMonths(), minusWeeks(), minusDays()
                            LocalTime, LocalDateTime
                                plusHours(), plusMinutes(), plusSeconds(), plusNanos()
                                plusHours(), minusMinutes(), minusSeconds(), minusNanos()
                            LocalDate, LocalTime, LocalDateTime
                                isBefore(), isAfter()
                            Example:
                                    LocalDate date = LocalDate.of(2024, Month.OCTOBER, 26); //Output is: 2024-10-26
                                    date = date.plusDays(2); //Output is: 2024-10-28
                                    date = date.plusWeeks(1); //Output is: 2024-11-04 (calculate from 2024-10-28)
                                    date = date.plusMonths(4); //Output is: 2025-03-04
                                    date = date.plusYears(3); //Output is: 2028-03-04
                            We can do method chaining:
                                    LocalDateTime localDateTime1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 23, 45, 21);
                                    localDateTime1 = localDateTime1.minusDays(2).plusHours(4).minusSeconds(20); //Output is: 2024-10-25T03:45:01
                    Date and time classes are immutable !!!
                            isBefore(), and isAfter()
                                    LocalDate date1 = LocalDate.of(2024, 10, 26);
                                    LocalDate date2 = LocalDate.of(2024, 10, 27);
                                    System.out.println(date1.isBefore(date2)); //Output is: true
                }
            }
31. Dates and Times: Period, Duration, Instant
        Period can be used only with LocalDate and LocalDateTime:
                Period p1 = Period.ofYears(2); //Output is: P2Y    (P2Y stands for Period of 2 Years)
                Period p2 = Period.ofMonths(3); //Output is: P3M    (P3M stands for Period of 3 Months)
                Period p3 = Period.ofWeeks(1); //Output is: P7D    (P7D stands for Period of 7 Days = 1 Week)
                Period p4 = Period.ofDays(11); //Output is: P11D    (P11D stands for Period of 11 Days)
                Period p5 = Period.of(2, 0, 15); //Output is: P2Y15D (P2Y15D stands for Period of 2 Years, zero Month, and 15 Days)
        Periods are used with plus/minus on date:
                Period period = Period.of(1, 2, 5);
                LocalDate date = LocalDate.of(2024, 10, 26);
                date = date.plus(period); //Output is: 2025-12-31
                date = date.minus(period); //Output is: 2024-10-26 (calculate from 2025-12-31)
        Duration can be used only with LocalTime and LocalDateTime:
                Duration dr1 = Duration.ofDays(3);     //Output is: PT72H    (PT72H stands for Period of Time 72 Hours)
                Duration dr2 = Duration.ofHours(3);    //Output is: PT3H
                Duration dr3 = Duration.ofMinutes(45); //Output is: PT45M
                Duration dr4 = Duration.ofSeconds(25); //Output is: PT25S
                Duration dr5 = Duration.ofMillis(230); //Output is: PT0.23S
                Duration dr6 = Duration.ofNanos(2503); //Output is: PT0.000002503S
        Using chronoUnits:
                import java.time.*;
                import java.time.temporal.*;
                Duration dr1 = Duration.of(3, ChronoUnit.HALF_DAYS);  //Output is: PT36H
                Duration dr2 = Duration.of(3, ChronoUnit.DAYS);  //Output is: PT72H
                Duration dr3 = Duration.of(3, ChronoUnit.HOURS);  //Output is: PT3H
                Duration dr4 = Duration.of(45, ChronoUnit.MINUTES);  //Output is: PT45M
                Duration dr5 = Duration.of(30, ChronoUnit.SECONDS);  //Output is: PT30S
                Duration dr6 = Duration.of(240, ChronoUnit.MILLIS);  //Output is: PT0.24S
                Duration dr7 = Duration.of(2503, ChronoUnit.NANNOS);  //Output is: PT0.000002503S
        ChronoUnits can also be used to determine how far apart are two times:
                    LocalTime t1 = LocalTime.of(17, 20);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 3
                Another
                    LocalTime t1 = LocalTime.of(17, 46);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 2 (even less than 3hours only 1 minutes, but it's still be counted as 2)
                Another
                    LocalTime t1 = LocalTime.of(17, 30);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.MINUTES.between(t1, t2)); //Output is: 195
        Durations are used with plus/minus on time:
                LocalTime time = LocalTime.of(17, 30);
                Duration duration = Duration.ofMinutes(45);
                time = time.plus(duration); //Output is: 18:15
                Duration duration = Duration.ofMinutes(45);
                time = time.minus(duration); //Output is: 16:45
        Instants are used to record time-stamps in the application
                Instant now = Instant.now();
                System.out.println(now); //Output is: 2024-10-27T00:25:52.923779102Z  (Z at the end, stands for zone time, because you are recording time-stamps in the application,
                                                                                       and application is running on your local machine, then it should be in your time zone,
                                                                                       so that is why only Z here, and thre's no specific zone id was added afer Z)
                Example: Measure duration of the process
                    Instant before = Instant.now();
                    //... some time-consuming process
                    Instant after = Instant.now();
                    Duration duration = Duration.between(before, after);
                    System.out.println(duration.toMillis()); //Output is: 255  (in milli seconds)
        Converting ZoneTimeDate to instant:
                ZoneId zone = ZoneId.of("Euro/Zagreb");
                ZonedDateTime z = ZonedDateTime.of(2024, 10, 27, 00, 33, 35, 145, zone);
                Instant instant = z.toInstant(); //Output is: 2024-10-27T00:33:35.000000145Z