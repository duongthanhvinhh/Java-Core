1. Can have multiple class in a java class file, but only one class in top-level, means only one class can be public. the others can not be given the public access modifier.
    Every class in java is automatically a subclass of the Object class
2. public void setName(String name) => the setName(String name) is called signature (signature includes the method name and the argument of the method)
3. java FodenClass "Foden" Foden  => input "Foden" or Foden can both be ok with java runtime
4. import java.util.* will import all classes under java.util, but not import subfolder of util folder
5. can compile multiple java class in one command: javac packagea/*.java packageb/*.java
6. if want to compile java file to class file and stored in another folder name classes: javac -d classes packagea/*.java packageb/*.java
7. to run the class files in 6:
    java -cp classes packagea.nameOfOneClassFileWithoutExtension
    or
    java -classpath ............................................
    or
    java --class-path ..........................................
8. java -cp ".;C:\com\demo\deps;C:\com\demo\myJar.jar" myPackage.MyApp
    To understand the above command, see below:
    C:\
     └── com\
         └── demo\
             ├── deps\
             │   ├── libA.jar
             │   └── libB.jar
             ├── myJar.jar
             │   └── myPackage\
             │       └── MyApp.class
             └── main.class
     first java to start jvm to execute java application
     second -cp to define classpaths, which is the path to the class files and Jar files that the application will need. The classpath contains multiple paths, separated by <;> semicolon (on Windows) or <:> colon on Unix/Linux
     third is class path: the first <.> represents the current directory which you are executing the command. Java will treat current folder as a base directory
                          C:\com\demo\deps This is the path to a directory that contains dependency libraries that MyApp need (libA.jar and libB.jar)
                          C:\com\demo\myJar.jar This is a specific jar file that contains compiled source code. For example, this file might contain some classes that your application uses
     Last is myPackage.MyApp This is the full name of the class. MyApp must have a method public static void main(String[] args) for java to know where to start.
9. Create your own jar file (from files in current folder)
    jar -cvf myNewJarFile.jar .
    or
    jar --create --verbose --file myNewJarFile.jar .
10. Create your own jar file (from files in custom folder)
    jar -cvf myNewJarFile.jar -C myFolder
    or
    jar --create --verbose --file myNewJarFile.jar -C myFolder
11. Foden foden = new Foden(); => In Java, when you create an instance of a class, the static blocks are executed only once when the class is loaded into memory,
                                  before any instances of the class are created. So, when you execute Foden foden = new Foden(); any static block in the Foden class
                                  will run before the constructor of Foden is executed.
12. Primitive Types:
    Definition: These are the basic data types provided by Java. They hold their values directly and are not objects.
        Characteristics:
                Fixed size.
                Stored in the stack memory.
                Represent simple values.
                Cannot be null.
        boolean: Type true or false, default value is false
        byte: 8bit integral value, from -128 to 127, default value is 0
        short: 16bit integral value, from -32,768 to 32,767, default value is 0
        int: 32bit integral value, from -2,147,483,648 to 2,147,483,647, default value is 0
        long: 64bit integral value, from -2^63 to 2^63 - 1, default value is 0L, example value is 5106L
        float: 32bit floating value, default value is 0.0f, example value is 511.183f
        double: 64bit floating value, default value is 0.0, example value is 511.183
        char: 16bit unicode value, from 0 to 65,535, default value is \u0000, example value is 'C'
        => To keep in mind:
            in Java, boolean true and false are completely unrelated to 1 and 0
            all numeric types are signed (allow negative numbers)
            float requires f (or F) at the end
                float x = 2.7; // Does not compile
                float x = 2.7f; // OK
            long requires l (or and preferably L) at the end
                long a = 45366546327; // Does not compile
                long a = 45366546327L; // OK
            for readability the use of underscore (_) is allowed, but NOT in the beginning or the end
                int a = 1_000_000; // normal usage
                int b = 1_2; // OK, but not very useful
                int c = 1________2; // even less useful, but still OK
                double d = 1_000_000.000_001 // OK and makes sense
                double x = _10.1; // NOK, do not allowed underscore at the beginning or the end
    Wrapper classes:
        Primitives are not objects, and sometimes we prefer to work with objects
        Each primitive has a wrapper class
        The most common way to create an object from the primitive is
            use static method valueOf()
            Example:
                Integer a = Integer.valueOf(5);  //First Integer is class name, then a is the reference variable, then class static method valueOf() of class Integer, 5 is the int literal
            Table:
                        |   Primitive Type  |   Wrapper class   |            Example            |
                        |    boolean        |   Boolean         | Boolean.valueOf(true)   ;     |
                        |    byte           |   Byte            | Byte.valueOf((byte) 12);      |
                        |    short          |   Short           | Short.valueOf((short) 12);    |
                        |    int            |   Integer         | Integer.valueOf(12);          |
                        |    long           |   Long            | Long.valueOf(12L);            |
                        |    float          |   Float           | Float.valueOf(12.0F);         |
                        |    double         |   Double          | Double.valueOf(12.0);         |
                        |    char           |   Character       | Character.valueOf('c');       |
            valueOf() can be used to convert String into wrapper class
            Example:
                Integer a = Integer.valueOf("12");    //Create variable with wrapper class type
        Wrapper classes come with some useful methods
            Convert string to int primitive type:
                    int intNumber = Integer.parseInt("101");  //Create variable with primitive type
            And some other useful methods: byteValue(), shortValue(), intValue(), floatValue(), doubleValue(), booleanValue(), and charValue()
                Example:
                    Double d = Double.valueOf(314.67);
                    System.out.println(d.byteValue()); //Output is: 58  (wrap: 314 - 256 = 58)
                    System.out.println(d.intValue()); //Output is: 314
                    System.out.println(d.doubleValue()); //Output is: 314.67
13. Non-Primitive Types:
    Definition: These are more complex data types that are derived from primitive types. They can hold multiple values and are always objects.
    Characteristics:
            Variable size.
            Stored in the heap memory.
            Can represent collections of values or complex data.
            Can be null.
    Strings: are not primitive types in Java, but they are commonly use like primitive
            String greeting = "hello world";
            ......................
            ......................
            ...Tobe continued.....
14. Stack and Heap memory:
    Stack:
        Definition: The stack is a region of memory that stores temporary variables created by each method (function) call. It operates in a last-in, first-out (LIFO) manner.
        Characteristics:
                Storage of Local Variables: Stack memory is used for storing local variables, method parameters, and references to objects in the heap.
                Automatic Memory Management: Memory is automatically allocated and deallocated. When a method is called, a new block (frame) is created on the stack.
                                             When the method returns, its frame is removed.
                Limited Size: Stack memory is generally smaller than heap memory. Its size is defined at the start of the application and can lead to a StackOverflowError
                              if too much memory is used (e.g., in deep recursion).
                Fast Access: Accessing data from the stack is faster than from the heap due to its structured nature.
        Example:
            public class StackExample {
                public static void main(String[] args) {
                    int localVariable = 10;  // Stored in stack
                    anotherMethod();
                }

                public static void anotherMethod() {
                    int anotherVariable = 20; // Also stored in stack
                }
            }
    Heap:
        Definition: The heap is a region of memory used for dynamic memory allocation, where objects are stored. It is managed by the Java Virtual Machine (JVM).
        Characteristics:
                Storage of Objects: All Java objects and their instance variables are stored in heap memory.
                Dynamic Allocation: Memory can be allocated and deallocated dynamically at runtime using the new keyword.
                                    Unlike the stack, memory in the heap is not automatically freed when a method exits.
                Garbage Collection: The JVM includes a garbage collector that automatically reclaims memory used by objects that are no longer referenced,
                                    helping to prevent memory leaks.
                Larger Size: Heap memory is generally larger than stack memory, allowing more significant data storage.
                             However, accessing heap memory can be slower than stack memory due to the overhead of memory management.
        Example:
            public class HeapExample {
                public static void main(String[] args) {
                    MyObject obj = new MyObject(); // obj is a reference stored in the stack, new object of MyObject is in the heap
                }
            }

            class MyObject {
                int value;

                MyObject() {
                    value = 10; // Instance variable stored in heap
                }
            }
15. Text Blocks: Is a new feature in Java 15
    i.e
        The old way: String title = "\"Java Core\"\n    by Foden Duong";
        String title = """
            "Java Core"
               by Foden Duong""";
        //The output:
            "Java Core"
               by Foden Duong
    => Remember, after the first """, should be the new line
       and after the second """, can be the new line or the same line but recommended the new line if you want compiler to insert a new line
       Any whitespace before the first non-empty character in the line after the 1st """ will be ignored by compiler.
       Compiler looks for the first non-empty character.
       But once the compiler finds the first non-empty character, then these spaces (before by Foden Duong""") will be essential,
       so these are part of the string.
16. Variables: is a name for a piece of memory which stores data
    To declare a variable: int x;
    To initialize a variable: int x = 5;
    Name of the variable (method, class, interface, package, ...) is called identifier
    Identifier rules:
        Must begin with a letter, currency symbol ($, ...), or underscore(_)
        Can include numbers, but not start with a number
        Single underscore(_) is not allowed as an identifier
        You cannot use the reserved word (like: abstract, case, continue, super, import, return, volatile, goto,...)
    Naming conventions:
        For variables, use camelCase
        For constants, use SNAKE_CASE
        Identifier of classes, interfaces, enums records start with first uppercase letter (e.g MyClass, MyInterface, StudentRecord)
        Identifiers variables and methods start with first lowercase letter (e.g fullName, getFullName())
        => Java identifier are case-sensitive !!
    Multiple variables can be declared/initialized in a single line (bad practice, but it compiles)
        int x, y;
        String firstName = "Foden", lastName = "Duong";
        boolean v = true, w, z = false;
    but you  cannot mix types (cannot declare variables of different type in a single line)
        int x, String name; // DOES NOT COMPILE
        or
        int x,
            String name: // "This is same line, as Java seperate lines by semicolon (;)", so DOES NOT COMPILE
    Three kinds of variables:
        Local variable - exist only within the block of code { ... }
        Instance variables (fields) - defined within the specific instance of the object
        Class variables - belong to a class and is shared with all instances of the class(marked with keyword static)
    Instance and class variables don't require initialization
        In-case you don't initialize variable, java will assume the defaults values of their type (i.e for doubles type, the default value is 0.0)
    Local variables must be initialized before use
        public int doesNotcompile(){
            int a = 3;
            int b;
            return a + b; // DOES NOT COMPILE as we use b but do not initialize it yet
        }
        but
        public int doesCompile(){
            int a = 5;
            int b = 3;
            int c;
            return a + b; // COMPIlE because c is not initialized but it's never used
        }
    Be careful if initialization is within if-statement
            public void doesNotCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5; // might never be reached
                }
                System.out.println(a); // DOES NOT COMPILE, variable a might not have been initialized
            }
            but
            public void doesCompile(boolean isOK){
                int a;
                if(isOK) {
                    a = 5;
                } else {
                    a = 2;
                }
                System.out.println(a); // COMPILE, because this variable a will be initialized one way or another
            }
    Final variables (constants)
        final int MAX_HEIGHT = 100;
        Final can be applied to a reference:
            final int[] MY_NUMBERS = new int[5];
            in this case, reference cannot be modified, but the content of the object can:
                        MY_NUMBERS[2] = 10; // OK
                        MY_NUMBERS = null; // DOES NOT COMPILE as you are trying to modified the reference
    Variable scope:
        Local variable: in scope from { to }
        Method parameters: in scope for the duration of the method
        Instance variable: in scope from declaration until the object is eligible for garbage collector
        Class variables: in scope from declaration until the program ends
17. Arguments and parameters in Java (Đối số và tham số trong Java):
    public void greeting(String message){ // message is parameter
        System.out.println(message);
    }
    greeting("Welcome to Java Core"); // Welcome to Java Core is argument
    => Tham số (parameter) được định nghĩa trong hàm
       Đối số (argument) là giá trị truyền vào khi gọi hàm
18. Call by value and call by reference:
    In Java, the distinction between call by value and call by reference is important to understand, especially when working with primitive types and objects.

    Call by Value
        In Java, all method arguments are passed by value. For primitive types (like int, float, etc.), a copy of the value is passed to the method.
        Changes made to the parameter do not affect the original variable.
        Example (Primitive Type):
            public class CallByValue {
                public static void increment(int x) {
                    x += 1;  // Changes the local copy only
                }

                public static void main(String[] args) {
                    int num = 5;
                    increment(num);
                    System.out.println(num);  // Output: 5 (original value remains unchanged)
                }
            }

    Call by Reference (for Objects)
        While Java does not support true call by reference, it passes object references by value.
        This means that a copy of the reference (pointer) to the object is passed.
        If you modify the object using this reference, the changes will be reflected in the original object.
        Example (Object Type):
            class MyClass {
                int value;
                MyClass(int value) {
                    this.value = value;
                }
            }
            public class CallByReference {
                public static void modify(MyClass obj) {
                    obj.value += 1;  // Changes the object referenced
                }
                public static void main(String[] args) {
                    MyClass myObj = new MyClass(5);
                    modify(myObj);
                    System.out.println(myObj.value);  // Output: 6 (original object is modified)
                }
            }
    Summary
    Call by Value: For primitives, a copy of the value is passed; changes do not affect the original variable.
    Call by Reference (for Objects): A copy of the reference to the object is passed; changes to the object affect the original object.
19. Local variable reference type:
        Example:
            var a = 5; //Compiler will automatically figure out the type of a is int based on the value you passed
            But
            var a = "Foden"; //DOES NOT COMPILE if put this line in the same scope of the above line. It means when the compiler figure out the type of variable,
                                we cannot reassign the type of it
            And we cannot use local variable reference type for null value
                var a = null; DOES NOT COMPILE
        Remember, var is not a reserved word (not like int, final,...), so we can create class, or method name Var
            public class Var {} //OK
            or
            var var = 5; //OK
            or
            Var var = new Var(); //OK
        Remember, it's only work for local variable
            public int sum (var a, var b){
                return a + b;
            } //DOES NOT COMPILE > as it is only work for local variable, not method variable
        Practical usage:
            Old way:
                ClassWithALongName myInstance = new ClassWithALongName();
                or
                ClientList<Client> clientList = new ClassWithALongName.getClientList();
            New way:
                var myInstance = new ClassWithALongName();
                or
                var clientList = new ClassWithALongName.getClientList();
20. Garbage Collection:
        All Java objects are stored in program's heap memory (aka free store)
        Garbage collection is just a process of automatically freeing memory on the heap
            By removing all the objects which are no longer reachable by the program (Objects are eligible for Garbage collection)
            This process is out of our control, it's for java to handle automatically
        There is a system method to force this process : System.gc(); // with this method you can suggest java to clean the heap
            But it's not guaranteed to do anything !! You can hope that Java will clean the heap, but you can not be guaranteed that Java will do anything
        Example:
            public class GcExample {
                public static void main(String[] args){
                    String a, b;
                    a = new String("Foden");
                    b = new String("Duong");
                    a = b;
                    String c = a;
                    a = null;
                }
            }
            Explain:
                        Reference (Stack memory)                    Object (Heap memory)
                    a ---------------------Reference a is pointed to object "Foden"-------------> "Foden"
                    b ---------------------Reference b is pointed to object "Duong"-------------> "Duong"
                    a = b, so now ---------Reference a is pointed to the object that is refered by b, that's "Duong"
                    now a is pointed to object "Duong" and no longer refered to "Foden",
                    then now "Foden" is eligible for Garbage collection and be removed from Heap memory
                    then String c = a -----c now is pointed to the object "Duong" which is also pointed to by a
                    then a = null, a no longer pointed to object "Duong" and now having value null
21. Operators
        There are 3 types of operators in Java:
            Unary operator: = Requires only one operator
                i++; Increases value by 1 and then return the OLD value
                    Example:
                        int a = 5;
                        int b = a++;
                        System.out.println(a); // = 6, because a++ increase value of a by 1
                        System.out.println(b); // still  = 5, because a++ increase value of a by 1, but return the OLD value, then it's 5
                ++i; Increases value by 1 and then return the NEW value
                    Example:
                        int x = 1;
                        int y = ++x*2
                        => y = (++x) * 2;
                        => y = 2 * 2
                        => y = 4;
            Binary operator:
                Addition: a + b;
                Subtraction: a - b;
                Multiplication: a * b;
                Division: a / b;
                Modulo operator: a % b;
                    Example:
                        11 / 2 = 5 (FLOOR value)
                        11 % 2 = 1 (Remainder of division)
                    Java promotes variable type, example:
                        short x = 5;
                        short y = 7;
                        System.out.println(x + y); // x and y are promoted to int, the result is int = 12
                        But
                        short z = x + y; //DOES NOT COMPILE as you try to put int to short
            Ternary operator:
                a = (b > 0) ? 3 : 4;
        Java automatically promotes smaller to larger data type
            Example:
                short x = 5;
                int y;
                y = x; //OK (x is casted to int )
            But can not do it in vice verse
            Example:
                int x = 5;
                short y;
                y = x; //DOES NOT COMPILE as you try to put int in short
                but, to have it work, you can cast type
                y = (short) x; //OK
        Expression a = 2 do 2 things:
            First, assign value 2 to a
            Second return value 2
            Example:
                int x = 5;
                int y = (x = 3) * 2;
                => x = 3; y = 6
        Favourite exam trick:
            boolean isOK = false;
            if(isOK = true){ // here the assignment operator = , not comparison operator == , so isOK is assigned to new value is true, the "true" will be printed out in the console
                System.out.println("true");
            } else {
                System.out.println("false");
            }
        Comparison operators
            Example:
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = name1;
                System.out.println(name1 = name2); //false because name1 and name2 are pointed to different object in the heap
                System.out.println(name1 = name3); //true because name1 and name3 are pointed to same object in the heap
22. Switch Statement:
        Default could be  anywhere in the block
        Be careful if there are no break statement:
            public void greeting(int a){
                switch(a){
                    case 1:
                        System.out.println("One");
                    default:
                        System.out.print("Maximum");
                    case 2:
                        System.out.print("Two");
                    case 3:
                        System.out.print("Three");
                }
            }
            greeting(5);// The results will be: Maximum Two Three, because there no break so after the default, it will execute all the case after default
23. Switch Expression:
        Java 8:
                    public void greeting(int a){
                        switch(a){
                            case 1:
                            case 2:
                            case 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Java 17:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3:
                                System.out.print("In first three int numbers");
                                break;
                            default:
                                System.out.print("Not in first three int numbers");
                                break;
                        }
                    }
        Another improvement in Java 17, using -> instead of : then you don't need break statement anymore:
                    public void greeting(int a){
                        switch(a){
                            case 1, 2, 3 -> System.out.print("In first three int numbers");
                            case 4, 5, 6 -> {
                                System.out.println("In first three int numbers");
                                System.out.println("Multiple command should be placed in {}");
                            }
                            default -> System.out.print("Not in first three int numbers");
                        }
                    }
        Real improvements, Switch statement can be treated as an expression:
                String alarmMeAboutNumber = switch(a){
                              case 1, 2, 3 -> "In first three int numbers";
                              default -> "Not in first three int numbers";
                          }; // need ; at the end because this is expression returns a string
        We can use yield keyword (similar to return statement in methods)
                Example:
                    int a = 1;
                    String greeting = switch(a) {
                                        case 0, 1, 2 -> {
                                            String str1 = "Good";
                                            String str2 = " day";
                                            yield str1 + str2;
                                        }
                                        case 3, 4 -> "Hi";
                                        default -> "Hello";
                                       };
                    System.out.println(greeting); // output is : Good day
                Another example:
                    public void greet(int a, int b){
                        String greeting = switch(a) {
                            case 0 -> "Good morning";
                            case 1 -> {
                                if(b > 0) yield "Good morning";
                                    else yield "Good afternoon";
                            }
                            case 2 -> "Hi";
                            default -> "Hello";
                        };
                        System.out.println(greeting)
                    }
                    greet(1, -1); // output is : Good afternoon
        Switch expression can return different value types:
            Example:
                public void greet(int a){
                    var printOut = switch(a){
                        case 0 -> "Good morning" //String
                        case 1 -> 5; //int
                        case 2 -> true; //boolean
                        default -> 3.14 //double
                    }
                }
        Switch expression must handle all possible cases -> it means the DEFAULT statement is REQUIRED (except for enum case)
        If we use enums, we can just list all possible values
            Example:
                enum Compass {NORTH, SOUTH, EAST, WEST}
                String getDirection(Compass value){
                    return switch(value){
                        case NORTH -> "Up";
                        case SOUTH -> "Down";
                        case EAST -> "Right";
                        case WEST -> "Left";
                    }
                }
                System.out.println(getDirection(Compass.SOUTH));
24. While Loop
        Using break in nested loops, with labels: To stop outer loop in case you're in inner loop
            Example:
                int i = 0; j = 0;
                OUTER_LOOP: while(true){
                    i++;
                    j = 0;
                    INNER_LOOP: while(true){
                        j++;
                        System.out.print("(" + i + "," + j + ")");
                        if(j == 3) break OUTER_LOOP; //break will turn into label OUTER_LOOP, then the outer loop will be ended.
                                                     //Output is (1,1), (1,2), (1,3)
                    }
                }
        or
        use return; to terminate the method
            Example:
                public void printPairs(){
                    int i = 0; j = 0;
                    OUTER_LOOP: while(true){
                        i++;
                        j = 0;
                        INNER_LOOP: while(true){
                            j++;
                            System.out.print("(" + i + "," + j + ")");
                            if(j == 3) return; //exist the method
                        }
                    }
                }
                printPairs(); //Output is (1,1), (1,2), (1,3)
25. For Loop:
        Can omit any one of the statements but still have to keep ; in place
        Infinite loop
             for( ; ; ){}
        You can use more than one index in a for loop, separated by comma
            for(int i = 0, j = 0; (i + j) < 5; i++, j++) {
                System.out.println("i=" + i + ", j=" + j);
                //output;
                    i=0, j=0
                    i=1, j=1
                    i=2, j=2
            }
26. For-Each Loop:
        Is often used to access the members of array (or collection, when you don't need access the index of member actually)

27. String
    String is a sequence of characters, implementing CharSequence interface:
    String name = "Foden";
    String name = new String("Foden");
    Concatenation:
            str1 + str2
        or
            str1.concat(str2)
        If both operands are numeric, + mean addition
        If either operand is String, + means concatenation
        Evaluation is left to right -> System.out.println("Foden" + 4 + 6); //Output is Foden46
                                       System.out.println("Foden" + (4 + 6)); //Output is Foden10
        It's allowed to concatenation with null string -> System.out.println("Foden" + null); //Output is Fodennull
    String Methods:
        length():
                String name = "Foden"; -> System.out.println(name.length()); //Output is 5
        charAt():
                String name = "Foden Duong"; -> System.out.println(name.charAt(6)); //Output is D (index start from 0, so char at index 6 is D)
                                             -> System.out.println(name.charAt(17)); //Output is StringIndexOutOfBoundException
        indexOf():
                String name = "Doctor Dolittle";    -> System.out.println(name.indexOf('t')); //Output is 3, start finding from index 0, and return the first index of character what is being searched
                                                    -> System.out.println(name.indexOf('t', 5)); //Output is 11, because start to find from index 5, so the t at index 3 will be ignored
                                                    -> System.out.println(name.indexOf("cto")); //Output is 2 that is the index of first character of string "cto"
                                                    -> System.out.println(name.indexOf("Do", 4)); //Output is 7
                                                    -> System.out.println(name.indexOf("A")); //Output is -1 , means not found
        substring():
                String name = "Foden Duong";    -> System.out.println(name.substring(4)); //Output is n Duong (includes start index to the end of string)
                                                -> System.out.println(name.substring(4, 8)); //Output is n Du (includes start index but does not include end index)
                                                -> System.out.println(name.substring(4, 4)); //Output is (output is empty string)
                                                -> System.out.println(name.substring(8, 4)); //Output is IndexOutOfBoundsException
                                                -> System.out.println(name.substring(4, 14)); //Output is IndexOutOfBoundsException
        toLowerCase():
                String name = "Foden Duong"; -> System.out.println(name.toLowerCase()); //Output is foden duong
        equals(), equalsIgnoreCase():
                String name1 = new String("Foden Duong");
                String name2 = new String("Foden Duong");
                String name3 = new String("foden Duong");
                System.out.println(name1 == name2); //false, because they are not referencing to the same object
                System.out.println(name1.equals(name2)); //true, because same content
                System.out.println(name1.equals(name3)); //false, because String is case-sensitive
                System.out.println(name1.equalsIgnoreCase(name3)); //true, method equalsIgnoreCase will ignore case sensitive
        startsWith(), endsWith():
                String name = "Foden Duong";
                System.out.println(name.startsWith("F")); //true
                System.out.println(name.startsWith("Fod")); //true
                System.out.println(name.endsWith("g")); //true
                System.out.println(name.endsWith("Duong")); //true
                System.out.println(name.startsWith('F')); //DOES NOT COMPILE, because argument must be a string, not char !
        contains():
                String name = "Foden Duong";
                System.out.println(name.contains("n")); //true
                System.out.println(name.contains('n')); //DOES NOT COMPILE, because string implements CharSequence, single quotes for char do not create a CharSequence, then compile error.
                                                        //need to pass a string or a single charater within double quote ""
                System.out.println(name.contains("en D")); //true
                System.out.println(name.contains("m")); //false
        replace():
                String str = "abcdeabc";
                System.out.println(str.replace('c', 'y')); //Output is abydeaby (replaces all instances of 'c' with 'y')
                System.out.println(str.replace("c", "y")); //Output is abydeaby (parameters can be both string and char)
                System.out.println(str.replace("abc", "fod")); //Output is foddeabc
        strip(), trim(), stripLeading(), stripTrailing():
                String str = " abc ";
                System.out.println(str.strip()); //Output is abc (strip() removes whitespaces at the beginning and the end, also supports unicode whitespace. It is a recommended way to use in case wanna remove whitespace at beginning and the end)
                System.out.println(str.trim()); //Output is abc (works same as strip() but does not support unicode whitespace)
                System.out.println("|" + str.stripLeading() + "|"); //Output is |abc | (remove the whitespaces at the beginning)
                System.out.println("|" + str.stripTrailing() + "|"); //Output is | abc| (remove the whitespaces at the end)
        indent(n) method:
                If n = 0 does nothing
                If n > 0 adds the same number of blank spaces to each line
                If n < 0 tries to remove n whitespace characters from the beginning of line
                Normalizes existing line breaks
                Adds line break at the end if missing
        stripIndent() method:
                Removes all leading incidental whitespace
                Normalizes existing line breaks
                Does not add line break at the end if missing
                    Example for indent(n) and stripIndent():
                        String str = "  Foden\n Duong";
                        System.out.println(str); Output is:  Foden
                                                            Duong
                        System.out.println(str.indent(2)); //Add 2 whitespaces add the beginning of each line Output is:    Foden
                                                                                                                           Duong
                        System.out.println(str.indent(-2)); //Remove 2 whitespaces add the beginning of each line Output is:  Foden
                                                                                                                             Duong
                        System.out.println(str.stripIndent()); //Remove all whitespaces of line having total of whitespaces is min, and remove that of whitespace for other lines ,
                                                               //in this case remove all spaces at the beginning of line Duong, and remove total of that whitespaces in line Foden Output is: Foden
                                                                                                                                                                                             Duong
        translateEscapes():
                String name = "Foden\\tDuong";
                System.out.println(name); //Output is Foden\tDuong (first t supports to escapes second t, then \t will be printed out)
                but
                System.out.println(name.translateEscapes()); //Output is Foden Duong (translateEscapes() method will support to understand the \t, then \t will be treated as a tab)
        isEmpty(), isBlank():
                System.out.println("".isEmpty()); //true
                System.out.println(" ".isEmpty()); //false, because it is not empty
                System.out.println("".isBlank()); //true
                System.out.println(" ".isBlank()); //true
        String formating symbols:
                %s for any type, usualy for String
                %d for integral values (int and long)
                %f for decimal numbers (float and double)
                    Example:
                        String name = "Foden";
                        int numberOfMembers = 5;
                        String printOut1 = "Family of " + name + " has " + numberOfMembers + " members.";
                        String printOut2 = String.format("Family of %s has %d members.", name, numberOfMembers);
                        String printOut3 = "Family of %s has %d members.".formatted(name, numberOfMembers);
                        => The 3 ways above gives the same result.
        Method chaining:
                left -> right
                String name = " Foden Duong ";
                System.out.println(name.trim().toUpperCase().replace('F','M')); //Output is Moden Duong
                !!!Strings are immutable
                String name = "Foden Duong";
                name.toUpperCase();
                System.out.println(name); //Output is still Foden Duong, because string is immutable, so the original value of string will be kept the same
                But
                name = name.toUpperCase();
                System.out.println(name); //Output now is FODEN DUONG
        String builder:
                StringBuilder is a mutable class which contains a String
                It has many methods for manipulating the strings
                    Example:
                        StringBuilder name = new StringBuilder("Foden Duong");
                Some methods work in the identical way as with a normal String substring(), indexOf(), length(), and charAt()
                Methods:
                        1. append():
                                StringBuilder name = new StringBuiler("Foden");
                                name.append("Duong");
                                System.out.println(name); //Output is FodenDuong (name is changed now, so can say StringBuilder is mutable)
                           chaining with append():
                                name.append(1).append(true);
                                System.out.println(name); //Output is FodenDuong1true (all arguments are converted to String)
                        2. insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. "); //insert to index 5 the Mr.
                                System.out.println(name); //Output is Foden Mr. Duong
                           chaining with insert():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                name.insert(6, "Mr. ").insert(6, "A"); //be careful, the first insert() will be performed in the original string, but the second insert will be performed in the new string after the first insert completed
                                System.out.println(name); //Output is Foden AMr. Duong
                        3. delete():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.delete(1, 4)); //Output is Fn Duong (remove all characters from 1 to 4, but exclude 4)
                        4. deleteCharAt():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.deleteCharAt( 4)); //Output is Fod Duong (remove character at index 4)
                                System.out.println(name.deleteCharAt( 15)); //Output is StringIndexOutOfBound
                        5. replace():
                                StringBuilder name = new StringBuilder("Foden Duong");
                                System.out.println(name.replace(0, 4, "Vinh")); //Output is Vinhn Duong (will replace string from 0 to index 4 - 1 = 3 by Vinh)
                                    If final index is too large, replace goes through the end (no exception !!)
                                        StringBuilder name = new StringBuilder("Foden Duong");
                                        name.replace(6, 100, "Vinh");
                                        System.out.println(name); //Output is Foden Vinh
                        6. reverse():
                                StringBuilder name = new StringBuilder("FODEN");
                                name.reverse();
                                System.out.println(name); //Output is NEDOF
                        7. toString():
                                StringBuilder name = new StringBuilder("FODEN");
                                String nameInString = name.toString();
                        8. equals():
                                => Remember StringBuilder doesn't implement equals() method, so if you use equals() for a string builder, it will treat as ==,
                                => then compiler will compare the references and if the reference is point to different object, it will be false
                                    Example:
                                        StringBuilder name1 = new StringBuilder("FODEN");
                                        StringBuilder name2 = new StringBuilder("FODEN");
                                        System.out.println(name1 == name2); //false
                                        System.out.println(name1.equals(name2)); //false as well, because StringBuilder doesn't implement equals() method, the it will treat equals() as ==
                                => !!! So if we want to compare content we have to convert it back to String:
                                        System.out.println(name1.toString().equals(name2.toString())); //Output is true
                        9. substring():
                                => StringBuilder is mutable class, but there is one exception: substring() returns a String and doesn't change the StringBuilder
                                        Example:
                                            StringBuilder name = new StringBuilder("Foden Duong");
                                            name.substring(6, 11);
                                            String subName = name.substring(6, 11);
                                            System.out.println(name); //Output is still Foden Duong (so StringBuilder.substring() is immutable - exception one)
                                            System.out.println(subName); //Output is Duong

28. String pool (or intern pool):
    When creating a new string with literal value "Foden", JVM stores it in the memory location known as String pool or intern pool (part of heap memory)
    Now creating a new string with same literal value "Foden", instead of creating a new memory spot for this literal value, JVM will look in the String pool,
        then it finds that literal already exists, it will point the new variable to the existing location in the String pool
    Example:
        String str1 = "Foden";
        String str2 = "Foden";
        System.out.println(str1 == str2); //true, because same content and point to the same location in String pool
        System.out.println(str1.equals(str2)); //true, equals only compare the content of these 2 strings
    But, tricky example #1
        String str1 = "Foden";
        String str2 = "   Foden  ".trim();
        System.out.println(str1 == str2); //false, because pool is created at compile-time, but trim() is evaluated at run-time
    Or even like this, it's still false
        String str1 = "Foden";
        String str2 = "   Foden  ";
        str2 = str2.trim();
        System.out.println(str2); //Output here is Foden, but the below line still getting false, because pool is created at compile-time, but trim() is evaluated at run-time
                                  //More explanation: During compile time, compiler will check 2 strings str1 = "Foden" and str2 = "   Foden  ", it sees that these 2 strings are
                                  //different, then it will assign them to 2 different memory spots in String pool, that's why even after trim(), str2 now is "Foden", but we still
                                  //get false when trying to compare str1 == str2
        System.out.println(str1 == str2);
    Tricky example #2
        String str1 = "Foden Duong";
        String str2 = "Foden" + " " + "Duong";
        System.out.println(str1 == str2); //true, because the concatenation is done in the compile-time
    There's way to get true in the tricky example #1: That is instruct the compiler to use the pool even with runtime methods
        String str1 = "Foden";
        String str2 = "   Foden  ".trim().intern(); //use intern() to tell the compiler that need to evaluate the trim() method
        System.out.println(str1 == str2); //true
29. Arrays
    Many ways to initialize an array:
            int[] nums = new int[3]; //declare first
            nums = new int[]{2, 1, 3}; //initialize later
        or
            int[] nums = new int[]{2, 1, 3};
        or
            int[] nums = {2, 1, 3};
    Can have multiple values in one declaration but not recommended:
            int[] nums, ages; // 2 arrays declared
        or
            int nums[], a; // 1 array and 1 int number declared
    Arrays don't implement equals() method, so if you use equals(), it will be treated as == comparison
    Printing out the array:
            int[] nums = {2, 1, 3};
            System.out.println(nums); //Output will something like this I@7a4f0f29, this is the hash code of reference nums.
        so to print out the array:
            System.out.println(Arrays.toString(nums)); //Output is [2, 1, 3]
    Every array has a property called length (It is a property, not a method)
            int[] nums = {2, 1, 3};
            System.out.println(nums.length); //Output is 3
    Methods of Arrays:
        Arrays.sort():
                int[] nums = new int[] {2, -4, 7, 17};
                Arrays.sort(nums);
                System.out.println(Arrays.toString(nums)); //Output is [-4, 2, 7, 17]
                => !!! Arrays are mutable,sort() changes the original array.
        Arrays.binarySearch():
                Works only on sorted arrays
                If array is not sorted, then the result is unpredictable
                This method takes array and array elements as arguments,
                    if element is found, the index of that element is returned
                    if element is not found, the negative number is returned -(index_where_it_would_belong + 1)
                Example:
                    int[] nums = new int[] {3, -1, 8};
                    Arrays.sort(nums); // sort array to have binarySearch() works, now array is {-1, 3, 8}
                    System.out.println(Arrays.binarySearch(nums, -1)); //Output is 0, the index of -1
                    System.out.println(Arrays.binarySearch(nums, 1)); //Output is -2, why ? if 1 exists in the array, then it should be index 1 => -(index_where_it_would_belong + 1) = -(1 + 1) = -2
        Arrays.compare():
                This method determines which array is smaller and returns:
                    Negative number if first array is smaller than second array
                    Zero number if the arrays are the same contents
                    Positive number if first array is larger than second array
                Definition of what is smaller here:
                    If one array has less number of elements than another, it's smaller
                    If both arrays have same number of elements:
                        Smaller is the one whose first different member is smaller
                        Example:
                            int[] nums = new int[] {3, -1, 8};
                            int[] nums1 = new int[] {3, -2, 8};
                            => then nums1 is smaller than nums
                        For Strings:
                            One is smaller if it is a prefix of another
                            Numbers are smaller than letters (i.e "232" is smaller than "Fo")
                            Uppercase is smaller than lowercase
                            Alphabetical order is applied
                    Null is smaller than any other values

                Some examples:
                    Arrays.compare(new int[]{3, 7}, new int[]{4}); => returns positive number, because first array has more elements than second one
                    Arrays.compare(new int[]{3, 7}, new int[]{3, 7}); => returns 0, because these 2 arrays has the same content
                    Arrays.compare(new String[]{"ab", "sdfs"}, new String[]{"abs", "shtr"}); => returns negative number, because first elements are different, can see "ab" is prefix of "abs",
                                                                                                then first array is smaller than second one
                    Arrays.compare(new String[]{"xy", "sdfs"}, new String[]{"abc", "shtr"}); => returns postive number, because first elements are different, can apply alphabetical order here,
                                                                                                because "x" is after "a", means "abs" is smaller than "xy", then means first array is larger than second array
                    Arrays.compare(new String[]{"Foden", "John"}, new String[]{"foden", "Duong"}); => returns negative number, because UpperCase is smaller than lowercase
        Arrays.mismatch():
                This method returns -1 if array are the same content, otherwise returns the first index where they differ
                Example:
                    Arrays.mismatch(new String[]{"Foden", "Duong"}, new String[]{"Foden", "Vinh"}); => return 1, that is the index of second element where they differ
    Multidimensional arrays:
        This is array of arrays:
        Example:
            int[][] a = {
                {-1, 3},
                {5},
                {45, 7, -2},
                {32, 6, 3, 11}
            }; => This array a has 4 elements type array, first element is an array has 2 element -1 and 3, ... so on
        Accessing elements with traditional loop:
            for(int i = 0; i < a.length; i++){
                for(int j = 0; j < a[i].length; j++){
                    System.out.println("a(%d, %d) = %d".formatted(i, j, a[i][j])); i is row, j is index in row = j is column
                }
            }
            The result like:
                a(0,0) = -1
                a(0,1) = 3
                a(1,0) = 5
                a(2,0) = 45
                ...........
        Accessing elements with for-each loop:
            for(int[] row : a){
                for(int column : row){
                    System.out.println("Element = " + element);
                }
            }
            The result like:
                Element = -1
                Element = 3
                Element = 5
                Element = 45
                ............
30. Dates and Times: Creating Date and Time, Methods on Dates and Times
            import java.time.*;  //If only use LocalDate, LocalTime, and LocalDateTime
            import java.time.temporal.*; //Import this one if you want to use chronounits
            public class DatesAndTimes {

                public static void main(String[] args) {
                    LocalDate localDate = LocalDate.now();
                    LocalTime localTime = LocalTime.now();
                    LocalDateTime localDateTime = LocalDateTime.now();
                    ZonedDateTime zonedDateTime = ZonedDateTime.now();
                    System.out.println(localDate);      //Output is: 2024-10-26
                    System.out.println(localTime);      //Output is: 22:46:33.977090400
                    System.out.println(localDateTime);  //Output is: 2024-10-26T22:46:33.977090400
                    System.out.println(zonedDateTime);  //Output is: 2024-10-26T22:46:33.978089600+07:00[Asia/Bangkok]

                    Creating local date: 2 ways
                            LocalDate d1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalDate d2 = LocalDate.of(2024, 10, 26);
                            System.out.println(d1); //Output is: 2024-10-26
                            System.out.println(d2); //Output is: 2024-10-26 (same as the way above using for creating d1)

                    Creating local time: Many ways to do that
                            LocalTime t1 = LocalTime.of(22, 52);
                            LocalTime t2 = LocalTime.of(22, 52, 38);
                            LocalTime t3 = LocalTime.of(22, 52, 38, 131);
                            System.out.println(t1); //Output is: 22:52
                            System.out.println(t2); //Output is: 22:52:38
                            System.out.println(t3); //Output is: 22:52:38.000000131

                    Creating local date-time: Many ways to do that
                            LocalDateTime dt1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 22, 55, 59); //yyyy, mm, dd, hh, mm, ss
                            LocalDate ld1 = LocalDate.of(2024, Month.OCTOBER, 26);
                            LocalTime lt1 = LocalTime.of(22, 55, 59);
                            LocalDateTime dt2 = LocalDateTime.of(ld1, lt1);
                            System.out.println(dt1); //Output is: 2024-10-26T22:55:59
                            System.out.println(dt2); //Output is: 2024-10-26T22:55:59 (same as above)

                    Creating zoned date-time:
                            ZoneId zoneId = ZoneId.of("Europe/Zagreb");
                            ZonedDateTime z1 = ZonedDateTime.of(2024, 10, 26, 23, 2, 19, 32,zoneId); //yyyy, mm, dd, hh, mm, ss, nano second, zoneId
                            System.out.println(z1); //Output is: 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb]
                             ==> +02:00 in the output means that the local time Europe/Zagreb is 2 hours ahead of UTC (Coordinated Universal Time) or aka GMT (Greenwich Mean Time)
                             ==> If UTC/GMT time is now 1PM, then at Europe/Zagreb it should be 3PM

                    For the exam, you need to know how to convert between time-zones:
                             ==> 2024-10-26T23:02:19.000000032+02:00[Europe/Zagreb] should be 2024-10-26T21:02:19.000000032 in UTC/GMT
                             ==> 2024-10-26T23:02:19.000000032-02:00[Europe/Zagreb] should be 2024-10-27T01:02:19.000000032 in UTC/GMT

                    Date-Time Methods:
                            LocalDate, LocalDateTime
                                plusYears(), plusMonths(), plusWeeks(), plusDays()
                                minusYears(), minusMonths(), minusWeeks(), minusDays()
                            LocalTime, LocalDateTime
                                plusHours(), plusMinutes(), plusSeconds(), plusNanos()
                                plusHours(), minusMinutes(), minusSeconds(), minusNanos()
                            LocalDate, LocalTime, LocalDateTime
                                isBefore(), isAfter()
                            Example:
                                    LocalDate date = LocalDate.of(2024, Month.OCTOBER, 26); //Output is: 2024-10-26
                                    date = date.plusDays(2); //Output is: 2024-10-28
                                    date = date.plusWeeks(1); //Output is: 2024-11-04 (calculate from 2024-10-28)
                                    date = date.plusMonths(4); //Output is: 2025-03-04
                                    date = date.plusYears(3); //Output is: 2028-03-04
                            We can do method chaining:
                                    LocalDateTime localDateTime1 = LocalDateTime.of(2024, Month.OCTOBER, 26, 23, 45, 21);
                                    localDateTime1 = localDateTime1.minusDays(2).plusHours(4).minusSeconds(20); //Output is: 2024-10-25T03:45:01
                    Date and time classes are immutable !!!
                            isBefore(), and isAfter()
                                    LocalDate date1 = LocalDate.of(2024, 10, 26);
                                    LocalDate date2 = LocalDate.of(2024, 10, 27);
                                    System.out.println(date1.isBefore(date2)); //Output is: true
                }
            }
31. Dates and Times: Period, Duration, Instant
        Period can be used only with LocalDate and LocalDateTime:
                Period p1 = Period.ofYears(2); //Output is: P2Y    (P2Y stands for Period of 2 Years)
                Period p2 = Period.ofMonths(3); //Output is: P3M    (P3M stands for Period of 3 Months)
                Period p3 = Period.ofWeeks(1); //Output is: P7D    (P7D stands for Period of 7 Days = 1 Week)
                Period p4 = Period.ofDays(11); //Output is: P11D    (P11D stands for Period of 11 Days)
                Period p5 = Period.of(2, 0, 15); //Output is: P2Y15D (P2Y15D stands for Period of 2 Years, zero Month, and 15 Days)
        Periods are used with plus/minus on date:
                Period period = Period.of(1, 2, 5);
                LocalDate date = LocalDate.of(2024, 10, 26);
                date = date.plus(period); //Output is: 2025-12-31
                date = date.minus(period); //Output is: 2024-10-26 (calculate from 2025-12-31)
        Duration can be used only with LocalTime and LocalDateTime:
                Duration dr1 = Duration.ofDays(3);     //Output is: PT72H    (PT72H stands for Period of Time 72 Hours)
                Duration dr2 = Duration.ofHours(3);    //Output is: PT3H
                Duration dr3 = Duration.ofMinutes(45); //Output is: PT45M
                Duration dr4 = Duration.ofSeconds(25); //Output is: PT25S
                Duration dr5 = Duration.ofMillis(230); //Output is: PT0.23S
                Duration dr6 = Duration.ofNanos(2503); //Output is: PT0.000002503S
        Using chronoUnits:
                import java.time.*;
                import java.time.temporal.*;
                Duration dr1 = Duration.of(3, ChronoUnit.HALF_DAYS);  //Output is: PT36H
                Duration dr2 = Duration.of(3, ChronoUnit.DAYS);  //Output is: PT72H
                Duration dr3 = Duration.of(3, ChronoUnit.HOURS);  //Output is: PT3H
                Duration dr4 = Duration.of(45, ChronoUnit.MINUTES);  //Output is: PT45M
                Duration dr5 = Duration.of(30, ChronoUnit.SECONDS);  //Output is: PT30S
                Duration dr6 = Duration.of(240, ChronoUnit.MILLIS);  //Output is: PT0.24S
                Duration dr7 = Duration.of(2503, ChronoUnit.NANNOS);  //Output is: PT0.000002503S
        ChronoUnits can also be used to determine how far apart are two times:
                    LocalTime t1 = LocalTime.of(17, 20);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 3
                Another
                    LocalTime t1 = LocalTime.of(17, 46);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.HOURS.between(t1, t2)); //Output is: 2 (even less than 3hours only 1 minutes, but it's still be counted as 2)
                Another
                    LocalTime t1 = LocalTime.of(17, 30);
                    LocalTime t2 = LocalTime.of(20, 45);
                    System.out.println(ChronoUnit.MINUTES.between(t1, t2)); //Output is: 195
        Durations are used with plus/minus on time:
                LocalTime time = LocalTime.of(17, 30);
                Duration duration = Duration.ofMinutes(45);
                time = time.plus(duration); //Output is: 18:15
                Duration duration = Duration.ofMinutes(45);
                time = time.minus(duration); //Output is: 16:45
        Instants are used to record time-stamps in the application
                Instant now = Instant.now();
                System.out.println(now); //Output is: 2024-10-27T00:25:52.923779102Z  (Z at the end, stands for zone time, because you are recording time-stamps in the application,
                                                                                       and application is running on your local machine, then it should be in your time zone,
                                                                                       so that is why only Z here, and thre's no specific zone id was added afer Z)
                Example: Measure duration of the process
                    Instant before = Instant.now();
                    //... some time-consuming process
                    Instant after = Instant.now();
                    Duration duration = Duration.between(before, after);
                    System.out.println(duration.toMillis()); //Output is: 255  (in milli seconds)
        Converting ZoneTimeDate to instant:
                ZoneId zone = ZoneId.of("Euro/Zagreb");
                ZonedDateTime z = ZonedDateTime.of(2024, 10, 27, 00, 33, 35, 145, zone);
                Instant instant = z.toInstant(); //Output is: 2024-10-27T00:33:35.000000145Z
32. Local and Instance variables:
        Local variables:
            Defined inside the block of code { }
            Can have only one optional modifier: final
                Once final variable is assigned a value it cannot be changed
            Effectively final: doesn't change value in the scope
                Variable is effectively final if you can put final in variable declaration and the code will still compile
            All local variables must be explicitly initialized before used
        Instance variables:
            Defined on class level, belong to instance of the class
            Can have different access modifiers: private, protected, public
            Can be marked as final, volatile, transient
            If not initialized, they assume default values depending on type
        Example of Local and Instance variables:
            class Item{
                public double tax = 0.2;  //Instance variable
                public double getPrice(double inputPrice){  //inputPrice is just a parameter for method
                    double margin = 0.05;  //Local variable
                    return inputPrice * (1 + tax) * (1 + margin);
                }
            }
            public class ItemHandlerPackage.ItemHandler{
                public static void main(String[] args){
                    Item item = new Item();  //Item item: item is a local variable
                    System.out.println(item.getPrice(100));
                    Item specialItem = new Item();  //Item specialItem: specialItem is a local variable
                    specialItem.tax = 0.1;  //Setting a new value for the instance variable tax of instance specialItem
                    System.out.println(specialItem.getPrice(100));
                }
            }
        Final variable:
            Whenever you defined a final variable, it needs to be initialized a value !!!
                    public double getPrice(double inputPrice){
                        double final margin;
                        margin = 0.05;
                        return inputPrice * (1 + tax) * (1 + margin);
                    }
            final means that variable reference is constant: the content can be modified, but the reference has to be constant
                    public void printSomething(){
                        final int[] a = {2, 5, 4};
                        a[1] = 3;  //OK , because we are changing the content not changing the reference
                        System.out.println(Arrays.toString(a));  // [2, 3, 4]
                        a = null; //DOES NOT COMPILE, because we are trying to change the reference
                    }
33. Variable  Arguments (Varargs):
        Helps method can accept any number of parameters of the same type
        Two rules to keep in mind:
            A method can have at most one varargs argument
            varargs argument must be the last parameter in the parameter list
        Example:
                public void greet(String greeting, String... names){
                    for(String name : names){
                        System.out.println(greeting + ", " + name + "!");
                    }
                }
                greet("Hello", "Foden", "Vinh"); //Output is: Hello, Foden!\n Hello, Vinh!
        You can pass an array as varargs
                String[] allMyNames = {"Foden", "Duong"};
                greet("Hello", allMyNames); //Output is the same: Hello, Foden!\n Hello, Vinh!
        You can NOT pass an array as varargs
                greet("Hello", {"Foden", "Duong"}); //DOES NOT COMPILE, because you are passing an anonymous array
            but
                greet("Hello", new String[] {"Foden", "Duong"}); //OK, because it's not an anonymous array ==> But this way is not recommended
        You can use varargs to write the main() method
                public static void main(String... args){}  //OK
34. Access modifiers: (src/main/java và src/test/java is just an organizational structure for source code and does not affect package identification
                       means if a class is created directly under src/main/java, and a class created directly under src/test/java, they're in the same package,
                       unless you create a package under these directories)
        private
            method or field can be accessed only within the class in which they are declared
        default (no keyword, means package-private)
            method or field can be accessed only within the same package
        protected
            method or field can be accessed within the same package and outside the package through child class
            means other class outside the package can only access protected method or field by extends the class, if you create instance of class instead of extends class,
            you can not access the method or field protected
        public
            method or field can be accessed from everywhere in the program
        Example: public, private
                class Dog{
                    private String genus = "Canis";
                    public void printGenus(){
                        System.out.println("Genus: " + genus);
                    }
                }
                public class MyClass{
                    public static void main(String[] args){
                        Dog dog = new Dog();
                        System.out.println(dog.genus); //DOES NOT COMPILE
                        dog.printGenus(); //OK, output is: Genus: Canis
                    }
                }
        Example:
                //Dog.java
                package zoo.dogs
                class Dog{
                    protected String genus = "Canis";
                }
                //Husky.java
                package zoo.huskys
                public class Husky extends Dogs{
                    public static void main(String[] args){
                        Husky husky = new Husky();
                        System.out.println(husky.genus); //OK, output is: Genus: Canis
                    }
                }
35. Static Members
        Static fields, and static methods don't belong to the instance of the class, but rather to class itself
            Example:
                    class Item{
                        public static double tax = 0.2;  //static mean tax belongs to the class Item, not to any instance of the class Item
                        public double getPrice(double inputPrice){
                            double margin = 0.05;
                            return inputPrice * (1 + tax) * (1 + margin);
                        }
                    }
                    public class MyClass{
                        public static void main(String[] args){
                            Item item1 = new Item();
                            System.out.println(item1.getPrice(100));  //Output is: 126.0
                            Item item2 = new Item();
                            item2.tax = 0.1;  //Because tax is static, this statement will change the value of tax for all instances of the class
                            System.out.println(item2.getPrice(100));  //Output is: 115.50000000000001       (tax used here has value 0.1)
                            System.out.println(item1.getPrice(100));  //Output is: 115.50000000000001       (tax used here also has value 0.1)
                        }
                    }
        Static members can be accessed directly, you don't need to create an instance of the object to access them
                class Dog{
                    public static void barks(){
                        System.out.println("Woof!");
                    }
                }
                public class MyClass{
                    public static void main(String[] args){
                        Dog.barks();
                        or you can also create instance then access it if you want
                        Dog dog = new Dog();
                        dog.barks(); //OK, but not recommended
                    }
                }
        Static methods can only call static fields directly
            Examples: with some problems to understand the context
                public class MyClass{
                    String hi = "Good afternoon!";
                    public static void greet1(){
                        System.out.println("Hello!");
                    }
                    private static void greet2(){
                        System.out.println(hi); //DOES NOT COMPILE, because method greet2() is static, and it's calling the variable hi which is non-static, it's not allowed by compiler
                                                //To fix, there are 3 ways, first way is make hi static. The second one is access via new instance of class: System.out.println(new MyClass().hi);
                                                //The third one is create a static instance of class, and use it at all:
                                                        public class MyClass{
                                                            String hi = "Good afternoon!";
                                                            static MyClass myClass = new MyClass();
                                                            .......................................
                                                            public static void greet2(){
                                                                System.out.println(myClass.hi);
                                                            }
                                                            ...................................
                                                        }

                    }
                    private void greet3(){
                        System.out.println("Good day!");
                    }
                    public static void greetAll(){
                        greet1();
                        greet2();
                        greet3(); //DOES NOT COMPILE, because method greetAll() is static, and it's calling the method greet3() which is non-static, it's not allowed by compiler
                                  //To fix, there are 3 ways same above
                    }
                    public static void main(String[] args){
                        MyClass.greetAll();
                    }
                }
        Constants:
            Are usually marked static final and written in SNAKE_CASE
                Example:
                        public class Item(){
                            public static final double VALUE_ADDED_TAX = 0.25;
                        }
            static final fields must be initialized before use, this could be done in a static block
                Example:
                        public class Item(){
                            public static final double VALUE_ADDED_TAX;
                            static{  //static block will be evaluated only once, when class is loaded to jvm for running,
                                     //means static block will be evaluated only when you invoke any static method of class, or create new instance of the class in which static block is located
                                VALUE_ADDED_TAX = 0.25;
                            }
                            public double calculatePrice(double price){
                                return price + price * VALUE_ADDED_TAX;
                            }
                        }
        static imports
            Are used to import static members of classes
                Example:
                    import java.lang.Math.pow;
                    ..........................
                    System.out.println(Math.pow(2,3)); //Output is 8
                    ..........................
                So if in your code, you need to simplify Math.pow(2,3) in case you repeatedly use it in the entire source code, you can do the static import
                    import static java.lang.Math.pow;  //the keyword `import` must be at the beginning of the line
                    .................................
                    System.out.println(pow(2,3)); //Now it's shorter
                    .................................
36. Boxing and Unboxing
        Boxing:
            Is a process of converting a primitive into its wrapper class (putting primitive in the box)
        Unboxing:
            Is a process of converting a wrapper class to a primitive (getting primitive out of the box)
            Explicit:
                Example:
                    int a = 4;
                    Integer b = Integer.valueOf(a);  //Convert int to Integer ==> boxing
                    int c = b.intValue();  //here a is the instance of wrapper class Integer, Convert wrapper to int ==> unboxing
            Implicit:
                Example:
                    int a = 4;
                    Integer b = a;  //Convert int to Integer ==> boxing (AutoBoxing)
                    int c = b;  //Convert wrapper to int ==> unboxing
        To remember:
            As you may know Java will autocast (auto casting) a smaller primitive into the larger one
            But Java will not do both automatic operations (autocast and autoboxing) at the same time!!!
            Example:
                int a = 3;
                long b = a; //Since int is a smaller primitive than long, then a will be auto-casted to long ==> OK
                but
                Long c = a; //DOES NOT COMPILE, because java will not perform autocast and autoboxing at the same time
                but
                Long c = Long.valueOf(a); //OK, because you explicit boxing here, java will only need to do one autocast operation
                and also
                Long c = (long) a; //OK, because you cast a from int to long, java will only need to do one autoboxing operation
                and also
                Long c = Long.valueOf((long) a); //OK, you cast a from int to long, and explicit do boxing here, then java doesn't need to do any automatic operation
            Another tricky example:
                Long a = 10; //here without L at the end, java will treat a as int number with value = 10 ==> DOES NOT COMPILE, because both autocasting and autoboxing is required here
                but
                Long a = 10L; //OK, java only need to perform autoboxing here
37. Method overloading
        Method overloading in Java allows you to define multiple methods with the same name but different parameters (different types, different total number of parameters, or order of parameters)
        Example:
                class MathOperations {
                    // Method to add two integers
                    public int add(int a, int b) {
                        return a + b;
                    }
                    // Overloaded method to add three integers
                    public int add(int a, int b, int c) {
                        return a + b + c;
                    }
                    // Overloaded method to add two doubles
                    public double add(double a, double b) {
                        return a + b;
                    }
                    // Overloaded method to add an integer and a double
                    public double add(int a, double b) {
                        return a + b;
                    }
                }
                public class Main {
                    public static void main(String[] args) {
                        MathOperations math = new MathOperations();

                        // Calling the different overloaded methods
                        System.out.println("Sum of two integers: " + math.add(5, 10)); // Calls add(int, int)
                        System.out.println("Sum of three integers: " + math.add(5, 10, 15)); // Calls add(int, int, int)
                        System.out.println("Sum of two doubles: " + math.add(5.5, 10.5)); // Calls add(double, double)
                        System.out.println("Sum of an integer and a double: " + math.add(5, 10.5)); // Calls add(int, double)
                    }
                }
        To remember:
            In passing argument doesn't exactly match the parameter type, java will pick the most similar version of the method
                    Example:
                        public void greet(int x) { System.out.println("parameter is int type"); }
                        public void greet(double x) { System.out.println("parameter is double type"); }
                        public void greet(int x, int y) { System.out.println("parameter is int type with 2 arguments"); }
                        short a = 2;
                        greet(a); //Output is: parameter is int type
                    Explanation:
                        When a short is passed to method greet(), Java first looks for a method that accepts an short parameter, if no such method exists, java will looks for larger primitive type is int, then long, ... and so on
                        with the list of Automatic Promotions as below:
                                byte → int, long, float, double     //For example, this one if java cannot find exact match for method with byte parameter, then will looks for a method accepts int, if still no, then long,... and so on
                                short → int, long, float, double
                                char → int, long, float, double    // You may be confused here, how char is promoted to int :D, char c = 'A'; // 'A' has a Unicode value of 65
                                                                                                                                int j = c;    // j now holds the value 65
                                                                                                                                System.out.println(j); // This will print 65
                                int → long, float, double
                                long → float, double
                                float → double
                    Another tricky example:
                               public void greet(Short a) { System.out.println("parameter is an instance of Short wrapper class"); }
                               public void greet(Integer a) { System.out.println("parameter is an instance of Integer wrapper class"); }
                               public void greet(String str) { System.out.println("parameter is an instance of String wrapper class"); }
                               public void greet(Object obj) { System.out.println("parameter is object type"); }
                               greet(2.3); //Java looks for a method with primitive type double, but you can see all of 4 methods above are not accepting any primitive parameter
                                           //So now Java will perform auto boxing, and it will convert double primitive into Double wrapper class
                                           //And then since there is NO greet() method which takes the instance of the wrapper class Double as a parameter
                                           //Java will try to find a superclass of the class Double, so this should be Object class (You already know every class in Java will automatically be a subclass of class Object)
                                           //So the method public void greet(Object obj) will be call here
                                           //Then Output is: parameter is object type
                               but
                               greet((short) 2); //Java looks for a method with primitive type short, but you can see all of 4 methods above are note accepting any primitive parameter
                                                 //So now Java will perform auto boxing, and it will convert short primitive into Short wrapper class
                                                 //Then Java found a method which accepts an instance of wrapper class Short as a parameter, which is public void greet(Short a)
                                                 //Then Output is: parameter is an instance of Short wrapper class
                    Another tricky example:
                            As you may know in the example above, after Java autoboxing primitive to wrapper class, then if it still cannot find any methods that accepts exact instance of wrapper class as a parameter
                            java will looks for a method accepts an object (because Object is actually a super class of every class in Java)
                            But
                            before Java looks for a method accepts an object, like an example above
                            java will looks for supertypes before looking for method accepts an object when it tries to determine which method to run
                                    public void greet(Number a) { System.out.println("Number abstract class here for a tricky example"); } //Number is an abstract class
                                                                                                                                           //and all other wrapper classes (except for String) which you get from your primitives,
                                                                                                                                           //they extend this abstract class Number
                                    public void greet(CharSequence a) { System.out.println("CharSequence interface here for a tricky example"); } //CharSequence is an interface
                                                                                                                                                  //and wrapper class String implements this interface CharSequence
                                                                                                                                                  //so we can say `CharSequence is a supertype of String`
                                    public void greet(Object obj) { System.out.println("Object class here for a tricky example"); }
                                    greet(3.14); //Since 3.14 is a double with primitive type, java will looks for a method which accepts exactly this primitive type first
                                                 //If there is NO, then this primitive double will be wrapped into wrapper class double
                                                 //And then since there is NO greet() method which takes an instance of wrapper class Double as a parameter
                                                 //Java will looks for the super type.
                                                 //Since Number is supertype of Double, then the method will be executed is
                                                 //public void greet(Number a)  ==> Output is: Number abstract class here for a tricky example
                                    greet("Foden"); //same above
                                                    //wrap "Foden" to String, which implements CharSequence ==> executed method: public void greet(CharSequence a) ==> Output is: Number abstract class here for a tricky example
                                    greet(new int[] {2, 1, 3}); //method public void greet(Object obj) will be executed ==> Output is: Object class here for a tricky example
            You cannot overload array with varargs !!!
                    Example:
                            public int doSomething(int[] nums) {  };
                            public int doSomething(int... nums) {  }; //DOES NOT COMPILE,
                                                                      //Because if you call method like this doSomething(new int[] {2, 1, 3});
                                                                      //It is impossible for Java to know which of these two methods to call, because it could be both
        In conclusion
                The order Java uses for finding the right overloaded methods:
                    Exact match by type
                    Larger primitive type
                    Autoboxed type
                    Supertype
35. Inheritence:
            Subclass can inherit members not private (fields and methods) from super class
            Java only supports single inheritance - Means class can only one direct superclass
      One class can implement multiple interface
      Class modifiers:
            final
          abstract
          static
          sealed     (java 17 or later)
          non-sealed (java 17 or later)
            All Java classes implicitly inherit from java.lang.Object class
      java.lang.Object class is the only class which doesn't have a parent class
      Every class has access to methods defined in Object class (e.g toString(), equals(), hashCode(), etc.)
36. Creating Classes:
            Keyword "this" is used to access the members of the class you're in
        Example:
            //Dog.java class
          public class Dog{
            private String name;
            protected int age;
            public void setAge(int age){
                this.age = age; //this.age to access the instance variable age of Dog class
            }
          }
      Setter method without using "this" in-case parameter name of method and instance field name are different
        Example:
            public void setAge(int theAge){
            age = theAge
          }
            Setter method using "this"
        Example:
            public void setAge(int age){
            this.age = age;
          }
            Keyword "super" is used to access the members of the superclass
        Example1:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Dog myDog = new Dog();
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
            Dog barks
        Example2:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Animal myDog = new Dog(); //create instance myDog type reference Animal, but it's still the object of Dog class,
                                                                //so it will still call sound() method in Dog class
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
            Dog barks
        Example3:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Animal myDog = new Animal(); //create instance myDog of Animal class
                                                                //so it will call sound() method in Animal class
              myDog.sound();
            }
          }
          //Output is:
            Animal makes a sound
        Example4:
            class Animal{
            void sound(){
                System.out.println("Animal makes a sound");
            }
          }
          class Dog extends Animal{
            void sound(){
                super.sound(); //call the parent class method
              System.out.println("Dog barks");
            }
          }
          public class Test{
            public static void main(String[] args){
                Dog myDog = new Animal(); //DOES NOT COMPILE, because you cannot assign a parent class object to a child class reference
                                                                //this is because a parent class does not have all the attributes and methods that might be present in a child class
                                        //then making it an invalid assignment
              myDog.sound();
            }
          }
        Example5:
            //Mammal.java class
          public class Mammal{
            private int age;
            protected String name;
            public void setAge(int age){
                this.age = age;
            }
            public int getAge(){
                return this.age;
            }
          }

          //Dog.java class
          public class Dog extends Mammal{
            //setNameAndAge method without using "super"
            protected void setNameAndAge(String dogName, int age){
                name = dogName;
              setAge(age);
            }
            //setNameAndAge method using "super"
            protected void setNameAndAge(String name, int age){
                super.name = name; //because instance name in parent class has same name as method parameter
                                                 //so need to use super.name to indicate that the name belongs to parent class
              setAge(age);
            }
          }
37. Creating Constructors
            Special methods which are called everytime you created an instance of an object
      Name of the constructor must match the name of the class
      Constructor don't have a return type !!!
            If the return type is stated, than it's just a normal method (name of method has the same name as class - Valid case but not recommended)
      Constructor overloading
            Example:
              public class Dog{
                private String name;
                private int age;
                public Dog() { System.out.println("Woof!"); }
                public Dog(String name, int age){
                  this.name = name;
                  this.age = age;
                }
                public Dog(String name) { this.name = name; }
                public Dog(int age) { this.age = age; }
                public Dog(boolean isPuppy, String name){
                  this.age = isPuppy ? 0 : -1;
                  this.name = name;
                }
                //Main method:

          }
            Constructors are usually made public
        But you can also make them protected, default or private
      Private constructors are used if you don't want public no-argument constructor to be generated by the compiler
        In this case, the instance is usually created via some static method, and not using the keyword new
        We have seen this behaviour in classes used to create Dates and Times
                LocalDate now = LocalDate.now(); //We cannot create instance like LocalDate now = new LocalDate();
                                                                             //This is because LocalDate class has a private constructor
                                                                                         //So in this case, instance is created when we call the static method now()
38. Using this() and super() keywords
            Special method this() is used to call another constructor in a constructor
                    Example:
                        public class Dog{
                          private String name;
                          private int age;
                          public Dog(String name, int age){
                            this.name = name;
                            this.age = age;
                          }
                          public Dog(){
                            this("Chip", 1); //this will call constructor public Dog(String name, int age)
                            System.out.println("Woof!");
                          }
                          public static void main(String[] args){
                            Dog dog = new Dog();
                            System.out.println("Name: " + dog.name + ", " + "Age: " + dog.age);
                            //Output is:
                                                        Woof!  (this is printed first, because this is printed out statement,
                                              so it will be executed first when obj instance is created, then this("Chip", 1) will be executed later)
                                  Name: Chip, Age: 1
                          }
                        }
                    There are several rules when using this()
                            this() can only be called in the first line in the constructor
                            this() can be called only once
                    becareful when create a "cycle", example constructor 1 uses this() to call constructor 2,
                                                     then constructor 2 use this() to call constructor 3,
                                                     ...becareful it can direct you to an infinite loop, then breaks your code 😃
                            Example1:
                                    public Dog(){
                                        System.out.println("Woof!");
                                      this("Chip", 1); //DOES NOT COMPILE, because this() must be called in the first line in the constructor
                                    }
                            Example2:
                                    public Dog(){
                                        this();  //constructor no-arg calls itself, then it will be in an infinite loop
                                                     //====> Then eventually a stack overflow error will be thrown
                                      System.out.println("Woof!");
                                    }
                            Example3:
                                    public Dog(){
                                        this("Chip", 1); //Call constructor below
                                      System.out.println("Woof!");
                                    }
                                    public Dog(String name, int age){
                                        this();  //Again call constructor above, then again call... ==> will be a cycle (infinite loop) ==> Stack Overflow Error
                                      this.name = name;
                                      this.age = age;
                                    }
            Special method super() is used to call a constructor of a superclass in a constructor of the subclass
                    Example:
                            //Mammal.java class
                            class Mammal{
                                public int age;
                              public Mammal(int age){
                                this.age = age;
                              }
                            }
                            public class Dog extends Mammal{
                                private String name;
                              public Dog(String name, int age){
                                super(age); //Call constructor of super/parent class
                                this.name = name;
                                System.out.println("Woof!");
                              }
                            }
                    Rules for using super()
                            If there is NO explicit this() or super() in the first line of the constructor
                                the compiler will insert super() at the beginning of EVERY constructor
                            Can be called only once (means everyone constructor in subclass can only call super() 1 times)
                            Must be called in the first line of the constructor
                            !!!If there is NO this() or super() in the first line, then the compiler will insert super() automatically
                                    Example:
                                        class Mammal{
                                        public int age;
                                      }
                                      public class Dog extends Mammal{
                                        private String name;
                                        public Dog(){
                                            ==>!!!because there's no this() or super() here,
                                          ==>  so compiler will insert the call for special method super()
                                          ==>  to call constructor no-arg of super class
                                          System.out.println("Woof!");
                                        }
                                      }
                            Be careful if the superClass doesn't have the no-argument constructor
                            Example:
                              class Mammal {
                                    private int age;
                                    public Mammal(int age){
                                        this.age = age;
                                    }

                                }
                              public class Main extends Mammal{
                                    public Main(){
                                            ==> DOES NOT COMPILE
                                        ==> Because in here there is NO super() or this(), then compiler will insert no-arg constructor of super class to here
                                        ==> But you can see in the super class Mammal, a constructor with parameter a is defined already public Mammal(int a) { this.age = age; }
                                        ==> So the default no-arg constructor will NOT be created, then when compiler trys to insert no-arg constructor to constructor of subclass
                                        ==> It cannot, because no-arg doesn't exist in super class, so that compilation error will be thrown in this case
                                        System.out.println("Test");
                                    }
                                    public static void main(String[] args){
                                        Main main = new Main();
                                    }
                                }
39. Initializing Objects
            Order of initialization
                What happens when we initialize a class?
                        If there is a superclass, it is initialized first
                        All static variables are processed (in order of appearence)
                        All static initializers are processed (in order of appearance)
                        ==> This all happens at most once for each class!!
            Class is initialized automatically if main() method is inside the class,
                or manually by calling "new ClassName();"
            Example:
                  class Mammal{
                      static { System.out.println("Hello."); }
                  }
                  public class Dog extends Mammal{
                    public static void main(String[] args){
                        System.out.println("Good afternoon.");
                      new Dog();
                      new Dog();
                    }
                    static { System.out.println("Woof!"); }
                  }
                  //Output is:
                    Hello.
                    Woof!
                    Good afternoon
                  //Explanation:
                        Main method inside class Dog, so class Dog will be initialized
                      Class Dog has superclass Mammal, so class Mammal will be initialized first
                      Then static block inside superclass Mammal will be initialized,
                      Then static block in side class Dog will be initialized
                      Then System.out.println() statement in main method will be called
                      Then new Dog(); new Dog(); makes no effect, because the rule above "This all happens at most once for each class!!"
